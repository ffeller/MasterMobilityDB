-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION mastermobilitydb cascade" to load this file. \quit

SET SEARCH_PATH TO MASTER, public ;

CREATE SCHEMA IF NOT EXISTS UTIL;

CREATE SCHEMA IF NOT EXISTS PARTITIONS;

CREATE SCHEMA IF NOT EXISTS STAGING;

CREATE TABLE MASTER.ASPECT
(
	ASPECT_ID            INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	X                    DOUBLE PRECISION NULL,
	Y                    DOUBLE PRECISION NULL,
	T                    TIMESTAMP NULL,
	SPACE_TIME           INTEGER NOT NULL,
	ASPECT_TYPE_ID       INTEGER NOT NULL
);

ALTER TABLE MASTER.ASPECT
ADD PRIMARY KEY (ASPECT_ID);

CREATE INDEX XIF1ASPECT ON ASPECT
(
	ASPECT_TYPE_ID
);

CREATE INDEX XIE1ASPECT ON ASPECT
(
	DESCRIPTION
);

CREATE SEQUENCE IF NOT EXISTS ASPECT_SEQ ;


CREATE TYPE ASPECT_TYP AS (
  ASPECT_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  X DOUBLE PRECISION,
  Y DOUBLE PRECISION,
  T TIMESTAMP,
  SPACE_TIME INTEGER,
  ASPECT_TYPE_ID INTEGER);


CREATE TABLE MASTER.ASPECT_ATTRIBUTE
(
	ASPECT_ID            INTEGER NOT NULL,
	ATTRIBUTE_ID         INTEGER NOT NULL,
	VALUE                TEXT NOT NULL,
	DATA_TYPE_ID         INTEGER NULL
);

ALTER TABLE MASTER.ASPECT_ATTRIBUTE
ADD PRIMARY KEY (ASPECT_ID,ATTRIBUTE_ID);

CREATE INDEX XIF1ASPECT_ATTRIBUTE ON ASPECT_ATTRIBUTE
(
	ASPECT_ID
);

CREATE INDEX XIF2ASPECT_ATTRIBUTE ON ASPECT_ATTRIBUTE
(
	ATTRIBUTE_ID
);

CREATE INDEX XIF3ASPECT_ATTRIBUTE ON ASPECT_ATTRIBUTE
(
	DATA_TYPE_ID
);

CREATE TYPE ASPECT_ATTRIBUTE_TYP AS (
  ASPECT_ID INTEGER,
  ATTRIBUTE_ID INTEGER,
  VALUE TEXT,
  DATA_TYPE_ID INTEGER);


CREATE TABLE MASTER.ASPECT_TYPE
(
	ASPECT_TYPE_ID       INTEGER NOT NULL,
	SUPER_TYPE_ID        INTEGER NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL
);

ALTER TABLE MASTER.ASPECT_TYPE
ADD PRIMARY KEY (ASPECT_TYPE_ID);

CREATE INDEX XIF1ASPECT_TYPE ON ASPECT_TYPE
(
	SUPER_TYPE_ID
);

CREATE SEQUENCE IF NOT EXISTS ASPECT_TYPE_SEQ ;


CREATE TYPE ASPECT_TYPE_TYP AS (
  ASPECT_TYPE_ID INTEGER,
  SUPER_TYPE_ID INTEGER,
  DESCRIPTION VARCHAR(50));


CREATE TABLE MASTER.ATTRIBUTE
(
	ATTRIBUTE_ID         INTEGER NOT NULL,
	NAME                 VARCHAR(30) NULL,
	ASPECT_TYPE_ID       INTEGER NULL,
	DATA_TYPE_ID         INTEGER NULL
);

ALTER TABLE MASTER.ATTRIBUTE
ADD PRIMARY KEY (ATTRIBUTE_ID);

CREATE INDEX XIF1ATRIBUTE ON ATTRIBUTE
(
	ASPECT_TYPE_ID
);

CREATE INDEX XIF2ATRIBUTE ON ATTRIBUTE
(
	DATA_TYPE_ID
);

CREATE SEQUENCE IF NOT EXISTS ATTRIBUTE_SEQ ;


CREATE TYPE ATTRIBUTE_TYP AS (
  ATTRIBUTE_ID INTEGER,
  NAME VARCHAR(30),
  ASPECT_TYPE_ID INTEGER,
  DATA_TYPE_ID INTEGER);


CREATE TABLE MASTER.DATA_TYPE
(
	DATA_TYPE_ID         INTEGER NOT NULL,
	DATA_TYPE_NAME       VARCHAR(30) NULL
);

ALTER TABLE MASTER.DATA_TYPE
ADD PRIMARY KEY (DATA_TYPE_ID);

CREATE SEQUENCE IF NOT EXISTS DATA_TYPE_SEQ ;


CREATE TYPE DATA_TYPE_TYP AS (
  DATA_TYPE_ID INTEGER,
  DATA_TYPE_NAME VARCHAR(30));


CREATE TABLE UTIL.DISABLED_FKS
(
	FK_ID                OID NULL,
	REL_ID               OID NOT NULL,
	FK_NAME              NAME NULL,
	FK_DEF               TEXT NULL,
	SCHEMA_NAME          NAME NULL
);

CREATE SEQUENCE IF NOT EXISTS DISABLED_FKS_SEQ ;


CREATE TYPE DISABLED_FKS_TYP AS (
  FK_ID OID,
  REL_ID OID,
  FK_NAME NAME,
  FK_DEF TEXT,
  SCHEMA_NAME NAME);


CREATE TABLE UTIL.DISABLED_INDEXES
(
	IND_ID               OID NULL,
	IND_NAME             NAME NOT NULL,
	REL_ID               OID NOT NULL,
	IND_DEF              TEXT NOT NULL,
	SCHEMA_NAME          NAME NOT NULL
);

CREATE SEQUENCE IF NOT EXISTS DISABLED_INDEXES_SEQ ;


CREATE TYPE DISABLED_INDEXES_TYP AS (
  IND_ID OID,
  REL_ID OID,
  IND_NAME NAME,
  IND_DEF TEXT,
  SCHEMA_NAME NAME);


CREATE TABLE MASTER.MAT
(
	MAT_ID               INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	MO_ID                INTEGER NOT NULL,
	RAW_TRAJECTORY       TGEOMPOINT NOT NULL,
	TRAJECTORY_GEOM      GEOMETRY NULL,
	MAT_DATE             DATE NULL
);

ALTER TABLE MASTER.MAT
ADD PRIMARY KEY (MAT_ID);

CREATE INDEX XIF1MAT ON MAT
(
	MO_ID
);

CREATE INDEX XIE1MAT ON MAT
(
	DESCRIPTION
);

CREATE SEQUENCE IF NOT EXISTS MAT_SEQ ;


CREATE TYPE MAT_TYP AS (
  MAT_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  MO_ID INTEGER,
  RAW_TRAJECTORY TGEOMPOINT,
  TRAJECTORY_GEOM GEOMETRY,
  MAT_DATE DATE);


CREATE TABLE MASTER.MAT_ASPECT
(
	MAT_ID               INTEGER NOT NULL,
	ASPECT_ID            INTEGER NOT NULL
);

ALTER TABLE MASTER.MAT_ASPECT
ADD PRIMARY KEY (MAT_ID,ASPECT_ID);

CREATE INDEX XIF1MAT_ASPECT ON MAT_ASPECT
(
	MAT_ID
);

CREATE INDEX XIF2MAT_ASPECT ON MAT_ASPECT
(
	ASPECT_ID
);

CREATE TYPE MAT_ASPECT_TYP AS (
  MAT_ID INTEGER,
  ASPECT_ID INTEGER);


CREATE TABLE MASTER.MO_ASPECT
(
	MO_ID                INTEGER NOT NULL,
	ASPECT_ID            INTEGER NOT NULL,
	START_TIME           TIMESTAMP NOT NULL,
	END_TIME             TIMESTAMP NULL
);

ALTER TABLE MASTER.MO_ASPECT
ADD PRIMARY KEY (MO_ID,ASPECT_ID);

CREATE INDEX XIF1MO_ASPECT ON MO_ASPECT
(
	MO_ID
);

CREATE INDEX XIF2MO_ASPECT ON MO_ASPECT
(
	ASPECT_ID
);

CREATE TYPE MO_ASPECT_TYP AS (
  MO_ID INTEGER,
  ASPECT_ID INTEGER,
  START_TIME TIMESTAMP,
  END_TIME TIMESTAMP);


CREATE TABLE MASTER.MO_RELATIONSHIP
(
	MOR_ID               INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	START_TIME           TIMESTAMP NOT NULL,
	END_TIME             TIMESTAMP NULL,
	MO_TARGET            INTEGER NOT NULL,
	MO_SOURCE            INTEGER NOT NULL
);

ALTER TABLE MASTER.MO_RELATIONSHIP
ADD PRIMARY KEY (MOR_ID);

CREATE INDEX XIF1MO_RELATIONSHIP ON MO_RELATIONSHIP
(
	MO_TARGET
);

CREATE INDEX XIF2MO_RELATIONSHIP ON MO_RELATIONSHIP
(
	MO_SOURCE
);

CREATE SEQUENCE IF NOT EXISTS MO_RELATIONSHIP_SEQ ;


CREATE TYPE MO_RELATIONSHIP_TYP AS (
  MOR_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  START_TIME TIMESTAMP,
  END_TIME TIMESTAMP,
  MO_TARGET INTEGER,
  MO_SOURCE INTEGER);


CREATE TABLE MASTER.MO_TYPE
(
	MO_TYPE_ID           INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL
);

ALTER TABLE MASTER.MO_TYPE
ADD PRIMARY KEY (MO_TYPE_ID);

CREATE SEQUENCE IF NOT EXISTS MO_TYPE_SEQ ;


CREATE TYPE MO_TYPE_TYP AS (
  MO_TYPE_ID INTEGER,
  DESCRIPTION VARCHAR(50));


CREATE TABLE MASTER.MOR_ASPECT
(
	MOR_ID               INTEGER NOT NULL,
	ASPECT_ID            INTEGER NOT NULL
);

ALTER TABLE MASTER.MOR_ASPECT
ADD PRIMARY KEY (MOR_ID,ASPECT_ID);

CREATE INDEX XIF1MO_RELATIONSHIP_ASPECT ON MOR_ASPECT
(
	MOR_ID
);

CREATE INDEX XIF2MO_RELATIONSHIP_ASPECT ON MOR_ASPECT
(
	ASPECT_ID
);

CREATE TYPE MOR_ASPECT_TYP AS (
  MOR_ID INTEGER,
  ASPECT_ID INTEGER);


CREATE TABLE MASTER.MOVING_OBJECT
(
	MO_ID                INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	MO_TYPE_ID           INTEGER NOT NULL
);

ALTER TABLE MASTER.MOVING_OBJECT
ADD PRIMARY KEY (MO_ID);

CREATE INDEX XIF1MOVING_OBJECT ON MOVING_OBJECT
(
	MO_TYPE_ID
);

CREATE INDEX XIE1MOVING_OBJECT ON MOVING_OBJECT
(
	DESCRIPTION
);

CREATE SEQUENCE IF NOT EXISTS MOVING_OBJECT_SEQ ;


CREATE TYPE MOVING_OBJECT_TYP AS (
  MO_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  MO_TYPE_ID INTEGER);


CREATE TABLE MASTER.POINT
(
	POINT_ID             INTEGER NOT NULL,
	P_ORDER              INTEGER NOT NULL,
	MAT_ID               INTEGER NOT NULL,
	T                    DATE NULL
);

ALTER TABLE MASTER.POINT
ADD PRIMARY KEY (POINT_ID);

CREATE INDEX XIF1POINT ON POINT
(
	MAT_ID
);

CREATE SEQUENCE IF NOT EXISTS POINT_SEQ ;


CREATE TYPE POINT_TYP AS (
  POINT_ID INTEGER,
  P_ORDER INTEGER,
  MAT_ID INTEGER,
  T DATE);


CREATE TABLE MASTER.POINT_ASPECT
(
	POINT_ID             INTEGER NOT NULL,
	ASPECT_ID            INTEGER NOT NULL
);

ALTER TABLE MASTER.POINT_ASPECT
ADD PRIMARY KEY (POINT_ID,ASPECT_ID);

CREATE INDEX XIF1POINT_ASPECT ON POINT_ASPECT
(
	POINT_ID
);

CREATE INDEX XIF2POINT_ASPECT ON POINT_ASPECT
(
	ASPECT_ID
);

CREATE TYPE POINT_ASPECT_TYP AS (
  POINT_ID INTEGER,
  ASPECT_ID INTEGER);


CREATE TABLE MASTER.POINT_REPR_POINT
(
	POINT_ID             INTEGER NOT NULL,
	REPR_POINT_ID        INTEGER NOT NULL
);

ALTER TABLE MASTER.POINT_REPR_POINT
ADD PRIMARY KEY (REPR_POINT_ID,POINT_ID);

CREATE INDEX XIF1POINT_REPR_POINT ON POINT_REPR_POINT
(
	POINT_ID
);

CREATE INDEX XIF2POINT_REPR_POINT ON POINT_REPR_POINT
(
	REPR_POINT_ID
);

CREATE SEQUENCE IF NOT EXISTS POINT_REPR_POINT_SEQ ;


CREATE TYPE POINT_REPR_POINT_TYP AS (
  POINT_ID INTEGER,
  REPR_POINT_ID INTEGER);


CREATE TABLE MASTER.REPR_POINT
(
	REPR_POINT_ID        INTEGER NOT NULL
);

ALTER TABLE MASTER.REPR_POINT
ADD PRIMARY KEY (REPR_POINT_ID);

CREATE UNIQUE INDEX XIF1REPR_POINT ON REPR_POINT
(
	REPR_POINT_ID
);

CREATE TYPE REPR_POINT_TYP AS (
  REPR_POINT_ID INTEGER);


ALTER TABLE MASTER.ASPECT
ADD CONSTRAINT R_31 FOREIGN KEY (ASPECT_TYPE_ID) REFERENCES MASTER.ASPECT_TYPE (ASPECT_TYPE_ID);

ALTER TABLE MASTER.ASPECT_ATTRIBUTE
ADD CONSTRAINT R_49 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.ASPECT_ATTRIBUTE
ADD CONSTRAINT R_50 FOREIGN KEY (ATTRIBUTE_ID) REFERENCES MASTER.ATTRIBUTE (ATTRIBUTE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.ASPECT_ATTRIBUTE
ADD CONSTRAINT R_52 FOREIGN KEY (DATA_TYPE_ID) REFERENCES MASTER.DATA_TYPE (DATA_TYPE_ID);

ALTER TABLE MASTER.ASPECT_TYPE
ADD CONSTRAINT R_51 FOREIGN KEY (SUPER_TYPE_ID) REFERENCES MASTER.ASPECT_TYPE (ASPECT_TYPE_ID);

ALTER TABLE MASTER.ATTRIBUTE
ADD CONSTRAINT R_39 FOREIGN KEY (ASPECT_TYPE_ID) REFERENCES MASTER.ASPECT_TYPE (ASPECT_TYPE_ID);

ALTER TABLE MASTER.ATTRIBUTE
ADD CONSTRAINT R_53 FOREIGN KEY (DATA_TYPE_ID) REFERENCES MASTER.DATA_TYPE (DATA_TYPE_ID);

ALTER TABLE MASTER.MAT
ADD CONSTRAINT R_54 FOREIGN KEY (MO_ID) REFERENCES MASTER.MOVING_OBJECT (MO_ID);

ALTER TABLE MASTER.MAT_ASPECT
ADD CONSTRAINT R_45 FOREIGN KEY (MAT_ID) REFERENCES MASTER.MAT (MAT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MAT_ASPECT
ADD CONSTRAINT R_46 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_ASPECT
ADD CONSTRAINT R_47 FOREIGN KEY (MO_ID) REFERENCES MASTER.MOVING_OBJECT (MO_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_ASPECT
ADD CONSTRAINT R_48 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_RELATIONSHIP
ADD CONSTRAINT R_20 FOREIGN KEY (MO_TARGET) REFERENCES MASTER.MOVING_OBJECT (MO_ID);

ALTER TABLE MASTER.MO_RELATIONSHIP
ADD CONSTRAINT R_21 FOREIGN KEY (MO_SOURCE) REFERENCES MASTER.MOVING_OBJECT (MO_ID);

ALTER TABLE MASTER.MOR_ASPECT
ADD CONSTRAINT R_37 FOREIGN KEY (MOR_ID) REFERENCES MASTER.MO_RELATIONSHIP (MOR_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MOR_ASPECT
ADD CONSTRAINT R_38 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MOVING_OBJECT
ADD CONSTRAINT R_19 FOREIGN KEY (MO_TYPE_ID) REFERENCES MASTER.MO_TYPE (MO_TYPE_ID);

ALTER TABLE MASTER.POINT
ADD CONSTRAINT R_40 FOREIGN KEY (MAT_ID) REFERENCES MASTER.MAT (MAT_ID);

ALTER TABLE MASTER.POINT_ASPECT
ADD CONSTRAINT R_42 FOREIGN KEY (POINT_ID) REFERENCES MASTER.POINT (POINT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_ASPECT
ADD CONSTRAINT R_43 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_REPR_POINT
ADD CONSTRAINT R_59 FOREIGN KEY (POINT_ID) REFERENCES MASTER.POINT (POINT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_REPR_POINT
ADD CONSTRAINT R_60 FOREIGN KEY (REPR_POINT_ID) REFERENCES MASTER.REPR_POINT (REPR_POINT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.REPR_POINT
ADD CONSTRAINT R_57 FOREIGN KEY (REPR_POINT_ID) REFERENCES MASTER.POINT (POINT_ID);

CREATE OR REPLACE PROCEDURE ASPECT_CREATE(
  INOUT P_ASPECT ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_ASPECT.ASPECT_ID := NEXTVAL('ASPECT_SEQ');
  INSERT INTO ASPECT(
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID)
  VALUES(
    P_ASPECT.ASPECT_ID, P_ASPECT.DESCRIPTION, P_ASPECT.X, P_ASPECT.Y, P_ASPECT.T, P_ASPECT.SPACE_TIME, P_ASPECT.ASPECT_TYPE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_CREATE
IS 'Creates one tuple on ASPECT from a ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE ASPECT_CREATE_MANY(
  INOUT P_ASPECT_A ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ASPECT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ASPECT_A[I].ASPECT_ID := NEXTVAL('ASPECT_SEQ');
  END LOOP;
  INSERT INTO ASPECT(
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID)
  SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM UNNEST(P_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_CREATE_MANY
IS 'Creates tuples on ASPECT from an array of ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION ASPECT_FIND_BY_ID(
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT
  WHERE 
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION ASPECT_FIND_BY_ID
IS 'Find all ocurrences on ASPECT based on primary key';

CREATE OR REPLACE FUNCTION ASPECT_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION ASPECT_FIND_BY_NAME
IS 'Find all ocurrences on ASPECT based on name or description';

CREATE OR REPLACE FUNCTION ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM ASPECT;
$BODY$;

COMMENT ON FUNCTION ASPECT_COUNT
IS 'Counts ocurrences on ASPECT';

CREATE OR REPLACE FUNCTION ASPECT_FIND_ALL() 
RETURNS SETOF ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT;
$BODY$;

COMMENT ON FUNCTION ASPECT_FIND_ALL()
IS 'Find all ocurrences on ASPECT';

CREATE OR REPLACE PROCEDURE ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM ASPECT;
$BODY$;

COMMENT ON PROCEDURE ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on ASPECT';

CREATE OR REPLACE PROCEDURE ASPECT_DELETE_BY_ID(
  IN P_ASPECT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ASPECT
  WHERE 
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_DELETE_BY_ID
IS 'Delete ocurrences on ASPECT based on primary key';

CREATE OR REPLACE PROCEDURE ASPECT_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ASPECT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE ASPECT_DELETE_BY_NAME
IS 'Delete ocurrences on ASPECT based on name';

CREATE OR REPLACE PROCEDURE ASPECT_UPDATE(
  IN P_ASPECT_A ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE ASPECT E
  SET 
    ASPECT_ID=P.ASPECT_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    X=P.X, 
    Y=P.Y, 
    T=P.T, 
    SPACE_TIME=P.SPACE_TIME, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID
  FROM UNNEST(P_ASPECT_A) P
  WHERE 
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_UPDATE
IS 'Updates all ocurrences on ASPECT based on array of ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE ASPECT_DELETE(
  IN P_ASPECT_A ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_A) P
    WHERE 
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE ASPECT_DELETE
IS 'Delete ocurrences on ASPECT based on array of ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_CREATE(
  INOUT P_ASPECT_ATTRIBUTE ASPECT_ATTRIBUTE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO ASPECT_ATTRIBUTE(
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID)
  VALUES(
    P_ASPECT_ATTRIBUTE.ASPECT_ID, P_ASPECT_ATTRIBUTE.ATTRIBUTE_ID, P_ASPECT_ATTRIBUTE.VALUE, P_ASPECT_ATTRIBUTE.DATA_TYPE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_CREATE
IS 'Creates one tuple on ASPECT_ATTRIBUTE from a ASPECT_ATTRIBUTE_TYP object';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_CREATE_MANY(
  INOUT P_ASPECT_ATTRIBUTE_A ASPECT_ATTRIBUTE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO ASPECT_ATTRIBUTE(
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID)
  SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM UNNEST(P_ASPECT_ATTRIBUTE_A);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_CREATE_MANY
IS 'Creates tuples on ASPECT_ATTRIBUTE from an array of ASPECT_ATTRIBUTE_TYP objects';

CREATE OR REPLACE FUNCTION ASPECT_ATTRIBUTE_FIND_BY_ID(
  IN P_ASPECT_ID INTEGER,
  IN P_ATTRIBUTE_ID INTEGER
) RETURNS SETOF ASPECT_ATTRIBUTE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM ASPECT_ATTRIBUTE
  WHERE 
    ASPECT_ID = P_ASPECT_ID AND
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;
$BODY$;

COMMENT ON FUNCTION ASPECT_ATTRIBUTE_FIND_BY_ID
IS 'Find all ocurrences on ASPECT_ATTRIBUTE based on primary key';

CREATE OR REPLACE FUNCTION ASPECT_ATTRIBUTE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM ASPECT_ATTRIBUTE;
$BODY$;

COMMENT ON FUNCTION ASPECT_ATTRIBUTE_COUNT
IS 'Counts ocurrences on ASPECT_ATTRIBUTE';

CREATE OR REPLACE FUNCTION ASPECT_ATTRIBUTE_FIND_ALL() 
RETURNS SETOF ASPECT_ATTRIBUTE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM ASPECT_ATTRIBUTE;
$BODY$;

COMMENT ON FUNCTION ASPECT_ATTRIBUTE_FIND_ALL()
IS 'Find all ocurrences on ASPECT_ATTRIBUTE';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM ASPECT_ATTRIBUTE;
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_DELETE_ALL()
IS 'Delete all ocurrences on ASPECT_ATTRIBUTE';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_DELETE_BY_ID(
  IN P_ASPECT_ID INTEGER,
  IN P_ATTRIBUTE_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ASPECT_ATTRIBUTE
  WHERE 
    ASPECT_ID = P_ASPECT_ID AND
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_DELETE_BY_ID
IS 'Delete ocurrences on ASPECT_ATTRIBUTE based on primary key';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_UPDATE(
  IN P_ASPECT_ATTRIBUTE_A ASPECT_ATTRIBUTE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE ASPECT_ATTRIBUTE E
  SET 
    ASPECT_ID=P.ASPECT_ID, 
    ATTRIBUTE_ID=P.ATTRIBUTE_ID, 
    VALUE=P.VALUE, 
    DATA_TYPE_ID=P.DATA_TYPE_ID
  FROM UNNEST(P_ASPECT_ATTRIBUTE_A) P
  WHERE 
    E.ASPECT_ID = P.ASPECT_ID AND
    E.ATTRIBUTE_ID = P.ATTRIBUTE_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_UPDATE
IS 'Updates all ocurrences on ASPECT_ATTRIBUTE based on array of ASPECT_ATTRIBUTE_TYP objects';

CREATE OR REPLACE PROCEDURE ASPECT_ATTRIBUTE_DELETE(
  IN P_ASPECT_ATTRIBUTE_A ASPECT_ATTRIBUTE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    ASPECT_ATTRIBUTE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_ATTRIBUTE_A) P
    WHERE 
      P.ASPECT_ID = T.ASPECT_ID AND
      P.ATTRIBUTE_ID = T.ATTRIBUTE_ID);
$BODY$;

COMMENT ON PROCEDURE ASPECT_ATTRIBUTE_DELETE
IS 'Delete ocurrences on ASPECT_ATTRIBUTE based on array of ASPECT_ATTRIBUTE_TYP objects';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_CREATE(
  INOUT P_ASPECT_TYPE ASPECT_TYPE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_ASPECT_TYPE.ASPECT_TYPE_ID := NEXTVAL('ASPECT_TYPE_SEQ');
  INSERT INTO ASPECT_TYPE(
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION)
  VALUES(
    P_ASPECT_TYPE.ASPECT_TYPE_ID, P_ASPECT_TYPE.SUPER_TYPE_ID, P_ASPECT_TYPE.DESCRIPTION);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_CREATE
IS 'Creates one tuple on ASPECT_TYPE from a ASPECT_TYPE_TYP object';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_CREATE_MANY(
  INOUT P_ASPECT_TYPE_A ASPECT_TYPE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ASPECT_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ASPECT_TYPE_A[I].ASPECT_TYPE_ID := NEXTVAL('ASPECT_TYPE_SEQ');
  END LOOP;
  INSERT INTO ASPECT_TYPE(
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION)
  SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM UNNEST(P_ASPECT_TYPE_A);
END;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_CREATE_MANY
IS 'Creates tuples on ASPECT_TYPE from an array of ASPECT_TYPE_TYP objects';

CREATE OR REPLACE FUNCTION ASPECT_TYPE_FIND_BY_ID(
  IN P_ASPECT_TYPE_ID INTEGER
) RETURNS SETOF ASPECT_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE
  WHERE 
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;
$BODY$;

COMMENT ON FUNCTION ASPECT_TYPE_FIND_BY_ID
IS 'Find all ocurrences on ASPECT_TYPE based on primary key';

CREATE OR REPLACE FUNCTION ASPECT_TYPE_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF ASPECT_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION ASPECT_TYPE_FIND_BY_NAME
IS 'Find all ocurrences on ASPECT_TYPE based on name or description';

CREATE OR REPLACE FUNCTION ASPECT_TYPE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM ASPECT_TYPE;
$BODY$;

COMMENT ON FUNCTION ASPECT_TYPE_COUNT
IS 'Counts ocurrences on ASPECT_TYPE';

CREATE OR REPLACE FUNCTION ASPECT_TYPE_FIND_ALL() 
RETURNS SETOF ASPECT_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE;
$BODY$;

COMMENT ON FUNCTION ASPECT_TYPE_FIND_ALL()
IS 'Find all ocurrences on ASPECT_TYPE';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM ASPECT_TYPE;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_DELETE_ALL()
IS 'Delete all ocurrences on ASPECT_TYPE';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_DELETE_BY_ID(
  IN P_ASPECT_TYPE_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ASPECT_TYPE
  WHERE 
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_DELETE_BY_ID
IS 'Delete ocurrences on ASPECT_TYPE based on primary key';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ASPECT_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_DELETE_BY_NAME
IS 'Delete ocurrences on ASPECT_TYPE based on name';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_UPDATE(
  IN P_ASPECT_TYPE_A ASPECT_TYPE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE ASPECT_TYPE E
  SET 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID, 
    SUPER_TYPE_ID=P.SUPER_TYPE_ID, 
    DESCRIPTION=P.DESCRIPTION
  FROM UNNEST(P_ASPECT_TYPE_A) P
  WHERE 
    E.ASPECT_TYPE_ID = P.ASPECT_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_UPDATE
IS 'Updates all ocurrences on ASPECT_TYPE based on array of ASPECT_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE ASPECT_TYPE_DELETE(
  IN P_ASPECT_TYPE_A ASPECT_TYPE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    ASPECT_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_TYPE_A) P
    WHERE 
      P.ASPECT_TYPE_ID = T.ASPECT_TYPE_ID);
$BODY$;

COMMENT ON PROCEDURE ASPECT_TYPE_DELETE
IS 'Delete ocurrences on ASPECT_TYPE based on array of ASPECT_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_CREATE(
  INOUT P_ATTRIBUTE ATTRIBUTE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_ATTRIBUTE.ATTRIBUTE_ID := NEXTVAL('ATTRIBUTE_SEQ');
  INSERT INTO ATTRIBUTE(
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID)
  VALUES(
    P_ATTRIBUTE.ATTRIBUTE_ID, P_ATTRIBUTE.NAME, P_ATTRIBUTE.ASPECT_TYPE_ID, P_ATTRIBUTE.DATA_TYPE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_CREATE
IS 'Creates one tuple on ATTRIBUTE from a ATTRIBUTE_TYP object';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_CREATE_MANY(
  INOUT P_ATTRIBUTE_A ATTRIBUTE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ATTRIBUTE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ATTRIBUTE_A[I].ATTRIBUTE_ID := NEXTVAL('ATTRIBUTE_SEQ');
  END LOOP;
  INSERT INTO ATTRIBUTE(
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID)
  SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM UNNEST(P_ATTRIBUTE_A);
END;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_CREATE_MANY
IS 'Creates tuples on ATTRIBUTE from an array of ATTRIBUTE_TYP objects';

CREATE OR REPLACE FUNCTION ATTRIBUTE_FIND_BY_ID(
  IN P_ATTRIBUTE_ID INTEGER
) RETURNS SETOF ATTRIBUTE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE
  WHERE 
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;
$BODY$;

COMMENT ON FUNCTION ATTRIBUTE_FIND_BY_ID
IS 'Find all ocurrences on ATTRIBUTE based on primary key';

CREATE OR REPLACE FUNCTION ATTRIBUTE_FIND_BY_NAME(
  IN P_NAME VARCHAR(30)
) RETURNS SETOF ATTRIBUTE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE
  WHERE NAME = P_NAME;
$BODY$;

COMMENT ON FUNCTION ATTRIBUTE_FIND_BY_NAME
IS 'Find all ocurrences on ATTRIBUTE based on name or description';

CREATE OR REPLACE FUNCTION ATTRIBUTE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM ATTRIBUTE;
$BODY$;

COMMENT ON FUNCTION ATTRIBUTE_COUNT
IS 'Counts ocurrences on ATTRIBUTE';

CREATE OR REPLACE FUNCTION ATTRIBUTE_FIND_ALL() 
RETURNS SETOF ATTRIBUTE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE;
$BODY$;

COMMENT ON FUNCTION ATTRIBUTE_FIND_ALL()
IS 'Find all ocurrences on ATTRIBUTE';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM ATTRIBUTE;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_DELETE_ALL()
IS 'Delete all ocurrences on ATTRIBUTE';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_DELETE_BY_ID(
  IN P_ATTRIBUTE_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ATTRIBUTE
  WHERE 
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_DELETE_BY_ID
IS 'Delete ocurrences on ATTRIBUTE based on primary key';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_DELETE_BY_NAME(
  IN P_NAME VARCHAR(30)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM ATTRIBUTE
  WHERE NAME = P_NAME;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_DELETE_BY_NAME
IS 'Delete ocurrences on ATTRIBUTE based on name';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_UPDATE(
  IN P_ATTRIBUTE_A ATTRIBUTE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE ATTRIBUTE E
  SET 
    ATTRIBUTE_ID=P.ATTRIBUTE_ID, 
    NAME=P.NAME, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID, 
    DATA_TYPE_ID=P.DATA_TYPE_ID
  FROM UNNEST(P_ATTRIBUTE_A) P
  WHERE 
    E.ATTRIBUTE_ID = P.ATTRIBUTE_ID;
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_UPDATE
IS 'Updates all ocurrences on ATTRIBUTE based on array of ATTRIBUTE_TYP objects';

CREATE OR REPLACE PROCEDURE ATTRIBUTE_DELETE(
  IN P_ATTRIBUTE_A ATTRIBUTE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    ATTRIBUTE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ATTRIBUTE_A) P
    WHERE 
      P.ATTRIBUTE_ID = T.ATTRIBUTE_ID);
$BODY$;

COMMENT ON PROCEDURE ATTRIBUTE_DELETE
IS 'Delete ocurrences on ATTRIBUTE based on array of ATTRIBUTE_TYP objects';

CREATE OR REPLACE PROCEDURE DATA_TYPE_CREATE(
  INOUT P_DATA_TYPE DATA_TYPE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_DATA_TYPE.DATA_TYPE_ID := NEXTVAL('DATA_TYPE_SEQ');
  INSERT INTO DATA_TYPE(
    DATA_TYPE_ID, DATA_TYPE_NAME)
  VALUES(
    P_DATA_TYPE.DATA_TYPE_ID, P_DATA_TYPE.DATA_TYPE_NAME);
END;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_CREATE
IS 'Creates one tuple on DATA_TYPE from a DATA_TYPE_TYP object';

CREATE OR REPLACE PROCEDURE DATA_TYPE_CREATE_MANY(
  INOUT P_DATA_TYPE_A DATA_TYPE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DATA_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DATA_TYPE_A[I].DATA_TYPE_ID := NEXTVAL('DATA_TYPE_SEQ');
  END LOOP;
  INSERT INTO DATA_TYPE(
    DATA_TYPE_ID, DATA_TYPE_NAME)
  SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM UNNEST(P_DATA_TYPE_A);
END;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_CREATE_MANY
IS 'Creates tuples on DATA_TYPE from an array of DATA_TYPE_TYP objects';

CREATE OR REPLACE FUNCTION DATA_TYPE_FIND_BY_ID(
  IN P_DATA_TYPE_ID INTEGER
) RETURNS SETOF DATA_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE
  WHERE 
    DATA_TYPE_ID = P_DATA_TYPE_ID;
$BODY$;

COMMENT ON FUNCTION DATA_TYPE_FIND_BY_ID
IS 'Find all ocurrences on DATA_TYPE based on primary key';

CREATE OR REPLACE FUNCTION DATA_TYPE_FIND_BY_NAME(
  IN P_DATA_TYPE_NAME VARCHAR(30)
) RETURNS SETOF DATA_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE
  WHERE DATA_TYPE_NAME = P_DATA_TYPE_NAME;
$BODY$;

COMMENT ON FUNCTION DATA_TYPE_FIND_BY_NAME
IS 'Find all ocurrences on DATA_TYPE based on name or description';

CREATE OR REPLACE FUNCTION DATA_TYPE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM DATA_TYPE;
$BODY$;

COMMENT ON FUNCTION DATA_TYPE_COUNT
IS 'Counts ocurrences on DATA_TYPE';

CREATE OR REPLACE FUNCTION DATA_TYPE_FIND_ALL() 
RETURNS SETOF DATA_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE;
$BODY$;

COMMENT ON FUNCTION DATA_TYPE_FIND_ALL()
IS 'Find all ocurrences on DATA_TYPE';

CREATE OR REPLACE PROCEDURE DATA_TYPE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM DATA_TYPE;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_DELETE_ALL()
IS 'Delete all ocurrences on DATA_TYPE';

CREATE OR REPLACE PROCEDURE DATA_TYPE_DELETE_BY_ID(
  IN P_DATA_TYPE_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM DATA_TYPE
  WHERE 
    DATA_TYPE_ID = P_DATA_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_DELETE_BY_ID
IS 'Delete ocurrences on DATA_TYPE based on primary key';

CREATE OR REPLACE PROCEDURE DATA_TYPE_DELETE_BY_NAME(
  IN P_DATA_TYPE_NAME VARCHAR(30)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM DATA_TYPE
  WHERE DATA_TYPE_NAME = P_DATA_TYPE_NAME;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_DELETE_BY_NAME
IS 'Delete ocurrences on DATA_TYPE based on name';

CREATE OR REPLACE PROCEDURE DATA_TYPE_UPDATE(
  IN P_DATA_TYPE_A DATA_TYPE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE DATA_TYPE E
  SET 
    DATA_TYPE_ID=P.DATA_TYPE_ID, 
    DATA_TYPE_NAME=P.DATA_TYPE_NAME
  FROM UNNEST(P_DATA_TYPE_A) P
  WHERE 
    E.DATA_TYPE_ID = P.DATA_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_UPDATE
IS 'Updates all ocurrences on DATA_TYPE based on array of DATA_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE DATA_TYPE_DELETE(
  IN P_DATA_TYPE_A DATA_TYPE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    DATA_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DATA_TYPE_A) P
    WHERE 
      P.DATA_TYPE_ID = T.DATA_TYPE_ID);
$BODY$;

COMMENT ON PROCEDURE DATA_TYPE_DELETE
IS 'Delete ocurrences on DATA_TYPE based on array of DATA_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE util.disable_fks(IN p_schema_name character varying, IN p_table_name character varying)
 LANGUAGE plpgsql
AS $procedure$
declare 
	c_fks record;
begin
	for c_fks in 
		select n.nspname schema_name, c."oid" fk_id, c.conrelid rel_id, 
			c.conname fk_name, pg_get_constraintdef(c."oid") fk_def 
		from pg_catalog.pg_constraint c
			inner join pg_catalog.pg_namespace n on
				c.connamespace = n.oid
			inner join pg_catalog.pg_class t on
				t."oid" = c.conrelid 
		where t.relname = p_table_name
			and n.nspname = p_schema_name
			and c.contype = 'f'
			and t.relkind = 'r'
	loop
		insert into util.disabled_fks(fk_id, rel_id, schema_name, fk_name, fk_def)
		values(c_fks.fk_id, c_fks.rel_id, c_fks.schema_name, c_fks.fk_name, 
			c_fks.fk_def);
	
		execute format(
			'alter table %s.%s drop constraint %s', p_schema_name, p_table_name, 
				c_fks.fk_name);	
	end loop;

	if not found then
		raise warning 'table %.% has no foreign keys to disable.', p_schema_name, 
			p_table_name;
	end if;
end;
$procedure$;

COMMENT ON PROCEDURE util.disable_fks
IS 'Disable foreign key constraints for the specified relation';

CREATE OR REPLACE PROCEDURE util.disable_indexes(IN p_schema_name character varying, IN p_table_name character varying)
 LANGUAGE plpgsql
AS $procedure$
declare 
	c_indexes record;
begin
	for c_indexes in 
		select i.indexrelid ind_id, i.indrelid rel_id, 
			n.nspname schema_name,  c.relname ind_name, 
			pg_get_indexdef(i.indexrelid) ind_def 
		from pg_catalog.pg_index i
			inner join pg_catalog.pg_class c on
				c."oid" = i.indexrelid 
			inner join pg_catalog.pg_namespace n on
				n."oid" = c.relnamespace 
			inner join (
				select c.oid, c.relname 
				from pg_catalog.pg_class c
					inner join pg_catalog.pg_namespace n on
						n."oid" = c.relnamespace 
				where n.nspname = p_schema_name
					and c.relname = p_table_name
				union all
				select i.inhrelid, s.relname 
				from pg_catalog.pg_inherits i
					inner join pg_catalog.pg_class p on
						p."oid" = i.inhparent 
					inner join pg_catalog.pg_class s on
						s."oid" = i.inhrelid 
					inner join pg_catalog.pg_namespace n on
						n."oid" = p.relnamespace 
				where n.nspname = p_schema_name
					and p.relname = p_table_name
			) r on i.indrelid = r.oid
		where not indisprimary 
		order by rel_id, ind_id
	loop
		insert into util.disabled_indexes(ind_id, rel_id, schema_name, ind_name, 
			ind_def)
		values(c_indexes.ind_id, c_indexes.rel_id, c_indexes.schema_name,
			c_indexes.ind_name, c_indexes.ind_def);
	
		execute format(
			'drop index %s.%s', c_indexes.schema_name, c_indexes.ind_name);	
	end loop;

	if not found then
		raise warning 'table % has no indexes to disable.', p_table_name;
	end if;
end;
$procedure$;

COMMENT ON PROCEDURE util.disable_indexes
IS 'Disable indexes for the specified relation';

CREATE OR REPLACE PROCEDURE util.drop_partitions_by_date(IN p_schemaname text, IN p_tablename text, IN p_startdate date, IN p_enddate date, IN p_interval text, IN p_schemapart text DEFAULT 'partitions'::text)
 LANGUAGE plpgsql
AS $procedure$
declare
  v_d date;
  v_partitionname text;
  v_interval text default '1 ' || p_interval;
 
  c_indexes record;
begin
  if not exists (
    select 1
    from information_schema.tables t
    where t.table_name = lower(p_tablename)
    	and t.table_schema = lower(p_schemaname)
  ) then
    raise exception 'table %.% does not exist', 
   		p_schemaname, p_tablename;
  end if;
 
  if p_startdate > p_enddate then
    raise exception 'the start date % must be before the end date %', 
   		p_startdate, p_enddate;
  end if;
 
  v_d := p_startdate;
 
  while v_d <= p_enddate 
  loop
    v_partitionname := p_tablename || '_' || to_char(v_d, 'yyyy_mm_dd');
   
    if exists (
      select 1
      from information_schema.tables t 
      where t.table_name = lower(v_partitionname)
       	and t.table_schema = lower(p_schemapart) 
				and exists (
					select 1 from pg_catalog.pg_inherits i
						inner join pg_catalog.pg_class p on
							p."oid" = i.inhparent
						inner join pg_catalog.pg_class c on
							c."oid" = i.inhrelid
						inner join pg_catalog.pg_namespace n on
							n."oid" = c.relnamespace
					where c.relname = t.table_name and 
						n.nspname = t.table_schema and
						p.relname = lower(p_tablename)) 
       )
    then
      execute format('drop table %s.%s', p_schemapart, v_partitionname);
		
      raise notice 'partition %.% has been dropped', 
     		p_schemapart, v_partitionname;
    end if;
   
    v_d := v_d + v_interval::interval;
  end loop;
end;
$procedure$;

COMMENT ON PROCEDURE util.drop_partitions_by_date
IS 'Drop partitions by date for the relation'
;

CREATE OR REPLACE PROCEDURE util.duplicate_table(IN p_schemaname text, IN p_tablename text, IN p_targetschema text, IN p_targettable text, IN p_percenttuples integer, IN p_startdate date, IN p_enddate date, IN p_columnname text, IN p_interval text, IN p_schemapart text)
 LANGUAGE plpgsql
AS $procedure$
declare
  c_indexes record;
begin
  if not exists (
    select *
    from information_schema.tables t
    where t.table_name = lower(p_tablename)
    	and t.table_schema = lower(p_schemaname)) 
  then
    raise exception 'table %.% does not exist', p_schemaname, p_tablename;
  end if;
 
  if not exists (
    select 1
     from information_schema.tables t
     where t.table_name = lower(p_targettable)
     	 and t.table_schema = lower(p_targetschema)
  ) then
   
    execute format(
    	'create table %s.%s as select * from %s.%s with no data', 
      p_targetschema, p_targettable, p_schemaname, p_tablename);

    for c_indexes in
			select 
				replace(
					replace(
						replace(
							pg_get_indexdef(i.indexrelid), 
							p_tablename || ' ', 
							p_targettable || ' '
						),
						p_tablename || '_pkey', 
						p_targettable || '_pkey'
					),
					p_schemaname,
					p_targetschema) ind_def 
			from pg_catalog.pg_index i
				inner join pg_catalog.pg_class c on
					c."oid" = i.indrelid 
				inner join pg_catalog.pg_namespace n on
					n."oid" = c.relnamespace 
				where c.relname = p_tablename
					and n.nspname = p_schemaname
	  loop 
	  	execute c_indexes.ind_def;
	  end loop;

	 	call util.create_partitions_by_date(p_targetschema, p_targettable, p_startdate
	 		, p_enddate, p_columnname, p_interval, p_schemapart);
	 	
	 	execute format('create or replace trigger insert_mat_trigger
    	before insert on %s.%s
    	for each row execute function master.mat_insert_trigger()',
    	p_targetschema, p_targettable);
 	
	 	call util.disable_fks(p_targetschema, p_targettable);
	 	call util.disable_indexes(p_targetschema, p_targettable);
	 
    execute format(
    	'insert into %s.%s select * from %s.%s tablesample system(%s)', 
      p_targetschema, p_targettable, p_schemaname, p_tablename, p_percenttuples);
	 	
	 	call util.enable_fks(p_targetschema, p_targettable);
	 	call util.enable_indexes(p_targetschema, p_targettable);

	 	raise notice 'Table %.% has been created', 
   		p_targetschema, p_targettable;
  end if;
   
end;
$procedure$;

COMMENT ON PROCEDURE util.duplicate_table
IS 'Duplicates a sample of the source relation to a target relation with partitions';

CREATE OR REPLACE PROCEDURE util.enable_fks(IN p_schema_name character varying, IN p_table_name character varying)
 LANGUAGE plpgsql
AS $procedure$
declare 
	c_fks record;
begin
	for c_fks in 
		select c.fk_id, c.rel_id, c.fk_name, c.fk_def 
		from util.disabled_fks c
			inner join pg_catalog.pg_class t on
				c.rel_id = t."oid" 
		where t.relname = p_table_name
			and c.schema_name = p_schema_name
			and t.relkind = 'r'
	loop
		execute format(
			'alter table %s.%s add constraint %s %s', p_schema_name, p_table_name, 
				c_fks.fk_name, c_fks.fk_def);

		delete from util.disabled_fks
		where fk_id = c_fks.fk_id;
	end loop;

	if not found then
		raise warning 'table %.% has no disabled foreign keys.', p_schema_name, p_table_name;
	end if;
end;
$procedure$;

COMMENT ON PROCEDURE util.enable_fks
IS 'Enables foreign key constraints for the specified relation'
;

CREATE OR REPLACE PROCEDURE util.enable_indexes(IN p_schema_name character varying, IN p_table_name character varying)
 LANGUAGE plpgsql
AS $procedure$
declare 
	c_indexes record;
begin
	for c_indexes in 
		select i.ind_id, i.rel_id, i.schema_name, i.ind_name, i.ind_def 
		from util.disabled_indexes i
			inner join (
				select c.oid, c.relname 
				from pg_catalog.pg_class c
					inner join pg_catalog.pg_namespace n on
						n."oid" = c.relnamespace 
				where c.relname = p_table_name
					and n.nspname = p_schema_name
				union all
				select i.inhrelid, s.relname 
				from pg_catalog.pg_inherits i
					inner join pg_catalog.pg_class p on
						p."oid" = i.inhparent 
					inner join pg_catalog.pg_class s on
						s."oid" = i.inhrelid
					inner join pg_catalog.pg_namespace n on
						n."oid" = p.relnamespace 
				where p.relname = p_table_name and
					n.nspname = p_schema_name
			) r on i.rel_id = r.oid
	loop
		execute format(c_indexes.ind_def);
	
		delete from util.disabled_indexes
		where ind_id = c_indexes.ind_id;
	end loop;

	if not found then
		raise warning 'table %.% has no disabled indexes.', p_schema_name, p_table_name;
	end if;
end;
$procedure$;

COMMENT ON PROCEDURE util.enable_indexes
IS 'Enable the disabled indexes for the specified relation'
;

CREATE OR REPLACE FUNCTION util.get_partition_by_date(p_schema_name text, p_table_name text, p_date date, p_schemapart text DEFAULT 'partitions'::text)
 RETURNS text
 LANGUAGE sql
AS $function$
	select max(s.relname)
	from pg_catalog.pg_inherits i
		inner join pg_catalog.pg_class p on
			p."oid" = i.inhparent 
		inner join pg_catalog.pg_class s on
			s."oid" = i.inhrelid 
		inner join pg_catalog.pg_namespace n on
			n."oid" = p.relnamespace 
		inner join pg_catalog.pg_namespace n2 on
			n2."oid" = s.relnamespace 
	where n.nspname = p_schema_name
		and p.relname = p_table_name
		and s.relkind = 'r'
		and s.relname <= format('%s_%s', p_table_name, to_char(p_date, 'yyyy_mm_dd'))
		and n2.nspname = p_schemapart;
$function$;

COMMENT ON FUNCTION util.get_partition_by_date 
IS 'Find the nearest partition for the specified table and date';

CREATE OR REPLACE PROCEDURE util.reset_sequence(IN p_schema_name character varying, IN p_table_name character varying)
 LANGUAGE plpgsql
AS $procedure$
declare
	v_att_name varchar;
begin
	select atr.attname into v_att_name
	from pg_catalog.pg_index i
		inner join pg_catalog.pg_class c on
			i.indrelid = c.oid
		inner join pg_catalog.pg_namespace n on
			c.relnamespace = n.oid
		inner join pg_catalog.pg_attribute atr on
	  	atr.attrelid = c.oid and 
	  	atr.attnum = any(i.indkey)
	where 
	  c.relname = p_table_name 
	  and n.nspname = p_schema_name
	 	and indisprimary
	 	and c.relkind = 'r';

	execute format(
		'select setval(''%1$s.%2$s_seq'', coalesce(max(%3$s), 1)) from %1$s.%2$s'
			, p_schema_name, p_table_name, v_att_name);
end;
$procedure$;

COMMENT ON PROCEDURE util.reset_sequence
IS 'Reset the sequence value to the max value of the related table';

CREATE OR REPLACE PROCEDURE util.reset_sequences(IN p_schema_name character varying)
 LANGUAGE plpgsql
AS $procedure$
begin
	call util.reset_sequence(p_schema_name, 'aspect');
	call util.reset_sequence(p_schema_name, 'aspect_type');
	call util.reset_sequence(p_schema_name, 'attribute');
	call util.reset_sequence(p_schema_name, 'data_type');
	call util.reset_sequence(p_schema_name, 'mat');
	call util.reset_sequence(p_schema_name, 'mo_relationship');
	call util.reset_sequence(p_schema_name, 'mo_type');
	call util.reset_sequence(p_schema_name, 'moving_object');
	call util.reset_sequence(p_schema_name, 'point');
end;
$procedure$;

COMMENT ON PROCEDURE util.reset_sequences 
IS 'Reset the sequences'' value at the specified schema';

CREATE OR REPLACE PROCEDURE MAT_CREATE(
  INOUT P_MAT MAT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_MAT.MAT_ID := NEXTVAL('MAT_SEQ');
  INSERT INTO MAT(
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE)
  VALUES(
    P_MAT.MAT_ID, P_MAT.DESCRIPTION, P_MAT.MO_ID, P_MAT.RAW_TRAJECTORY, P_MAT.TRAJECTORY_GEOM, P_MAT.MAT_DATE);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_CREATE
IS 'Creates one tuple on MAT from a MAT_TYP object';

CREATE OR REPLACE PROCEDURE MAT_CREATE_MANY(
  INOUT P_MAT_A MAT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MAT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MAT_A[I].MAT_ID := NEXTVAL('MAT_SEQ');
  END LOOP;
  INSERT INTO MAT(
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE)
  SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM UNNEST(P_MAT_A);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_CREATE_MANY
IS 'Creates tuples on MAT from an array of MAT_TYP objects';

CREATE OR REPLACE FUNCTION MAT_FIND_BY_ID(
  IN P_MAT_ID INTEGER
) RETURNS SETOF MAT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT
  WHERE 
    MAT_ID = P_MAT_ID;
$BODY$;

COMMENT ON FUNCTION MAT_FIND_BY_ID
IS 'Find all ocurrences on MAT based on primary key';

CREATE OR REPLACE FUNCTION MAT_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF MAT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION MAT_FIND_BY_NAME
IS 'Find all ocurrences on MAT based on name or description';

CREATE OR REPLACE FUNCTION MAT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MAT;
$BODY$;

COMMENT ON FUNCTION MAT_COUNT
IS 'Counts ocurrences on MAT';

CREATE OR REPLACE FUNCTION MAT_FIND_ALL() 
RETURNS SETOF MAT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT;
$BODY$;

COMMENT ON FUNCTION MAT_FIND_ALL()
IS 'Find all ocurrences on MAT';

CREATE OR REPLACE PROCEDURE MAT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MAT;
$BODY$;

COMMENT ON PROCEDURE MAT_DELETE_ALL()
IS 'Delete all ocurrences on MAT';

CREATE OR REPLACE PROCEDURE MAT_DELETE_BY_ID(
  IN P_MAT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MAT
  WHERE 
    MAT_ID = P_MAT_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_DELETE_BY_ID
IS 'Delete ocurrences on MAT based on primary key';

CREATE OR REPLACE PROCEDURE MAT_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MAT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE MAT_DELETE_BY_NAME
IS 'Delete ocurrences on MAT based on name';

CREATE OR REPLACE PROCEDURE MAT_UPDATE(
  IN P_MAT_A MAT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MAT E
  SET 
    MAT_ID=P.MAT_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    MO_ID=P.MO_ID, 
    RAW_TRAJECTORY=P.RAW_TRAJECTORY, 
    TRAJECTORY_GEOM=P.TRAJECTORY_GEOM, 
    MAT_DATE=P.MAT_DATE
  FROM UNNEST(P_MAT_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_UPDATE
IS 'Updates all ocurrences on MAT based on array of MAT_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_DELETE(
  IN P_MAT_A MAT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MAT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID);
$BODY$;

COMMENT ON PROCEDURE MAT_DELETE
IS 'Delete ocurrences on MAT based on array of MAT_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_CREATE(
  INOUT P_MAT_ASPECT MAT_ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_ASPECT(
    MAT_ID, ASPECT_ID)
  VALUES(
    P_MAT_ASPECT.MAT_ID, P_MAT_ASPECT.ASPECT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_CREATE
IS 'Creates one tuple on MAT_ASPECT from a MAT_ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_CREATE_MANY(
  INOUT P_MAT_ASPECT_A MAT_ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_ASPECT(
    MAT_ID, ASPECT_ID)
  SELECT
    MAT_ID, ASPECT_ID
  FROM UNNEST(P_MAT_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_CREATE_MANY
IS 'Creates tuples on MAT_ASPECT from an array of MAT_ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION MAT_ASPECT_FIND_BY_ID(
  IN P_MAT_ID INTEGER,
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF MAT_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, ASPECT_ID
  FROM MAT_ASPECT
  WHERE 
    MAT_ID = P_MAT_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION MAT_ASPECT_FIND_BY_ID
IS 'Find all ocurrences on MAT_ASPECT based on primary key';

CREATE OR REPLACE FUNCTION MAT_ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MAT_ASPECT;
$BODY$;

COMMENT ON FUNCTION MAT_ASPECT_COUNT
IS 'Counts ocurrences on MAT_ASPECT';

CREATE OR REPLACE FUNCTION MAT_ASPECT_FIND_ALL() 
RETURNS SETOF MAT_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, ASPECT_ID
  FROM MAT_ASPECT;
$BODY$;

COMMENT ON FUNCTION MAT_ASPECT_FIND_ALL()
IS 'Find all ocurrences on MAT_ASPECT';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MAT_ASPECT;
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on MAT_ASPECT';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_DELETE_BY_ID(
  IN P_MAT_ID INTEGER,
  IN P_ASPECT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MAT_ASPECT
  WHERE 
    MAT_ID = P_MAT_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_DELETE_BY_ID
IS 'Delete ocurrences on MAT_ASPECT based on primary key';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_UPDATE(
  IN P_MAT_ASPECT_A MAT_ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MAT_ASPECT E
  SET 
    MAT_ID=P.MAT_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_MAT_ASPECT_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID AND
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_UPDATE
IS 'Updates all ocurrences on MAT_ASPECT based on array of MAT_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_ASPECT_DELETE(
  IN P_MAT_ASPECT_A MAT_ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MAT_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_ASPECT_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID AND
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE MAT_ASPECT_DELETE
IS 'Delete ocurrences on MAT_ASPECT based on array of MAT_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MO_ASPECT_CREATE(
  INOUT P_MO_ASPECT MO_ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_ASPECT(
    MO_ID, ASPECT_ID, START_TIME, END_TIME)
  VALUES(
    P_MO_ASPECT.MO_ID, P_MO_ASPECT.ASPECT_ID, P_MO_ASPECT.START_TIME, P_MO_ASPECT.END_TIME);
END;
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_CREATE
IS 'Creates one tuple on MO_ASPECT from a MO_ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE MO_ASPECT_CREATE_MANY(
  INOUT P_MO_ASPECT_A MO_ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_ASPECT(
    MO_ID, ASPECT_ID, START_TIME, END_TIME)
  SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM UNNEST(P_MO_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_CREATE_MANY
IS 'Creates tuples on MO_ASPECT from an array of MO_ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION MO_ASPECT_FIND_BY_ID(
  IN P_MO_ID INTEGER,
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF MO_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM MO_ASPECT
  WHERE 
    MO_ID = P_MO_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION MO_ASPECT_FIND_BY_ID
IS 'Find all ocurrences on MO_ASPECT based on primary key';

CREATE OR REPLACE FUNCTION MO_ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MO_ASPECT;
$BODY$;

COMMENT ON FUNCTION MO_ASPECT_COUNT
IS 'Counts ocurrences on MO_ASPECT';

CREATE OR REPLACE FUNCTION MO_ASPECT_FIND_ALL() 
RETURNS SETOF MO_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM MO_ASPECT;
$BODY$;

COMMENT ON FUNCTION MO_ASPECT_FIND_ALL()
IS 'Find all ocurrences on MO_ASPECT';

CREATE OR REPLACE PROCEDURE MO_ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MO_ASPECT;
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on MO_ASPECT';

CREATE OR REPLACE PROCEDURE MO_ASPECT_DELETE_BY_ID(
  IN P_MO_ID INTEGER,
  IN P_ASPECT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MO_ASPECT
  WHERE 
    MO_ID = P_MO_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_DELETE_BY_ID
IS 'Delete ocurrences on MO_ASPECT based on primary key';

CREATE OR REPLACE PROCEDURE MO_ASPECT_UPDATE(
  IN P_MO_ASPECT_A MO_ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MO_ASPECT E
  SET 
    MO_ID=P.MO_ID, 
    ASPECT_ID=P.ASPECT_ID, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME
  FROM UNNEST(P_MO_ASPECT_A) P
  WHERE 
    E.MO_ID = P.MO_ID AND
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_UPDATE
IS 'Updates all ocurrences on MO_ASPECT based on array of MO_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MO_ASPECT_DELETE(
  IN P_MO_ASPECT_A MO_ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MO_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_ASPECT_A) P
    WHERE 
      P.MO_ID = T.MO_ID AND
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE MO_ASPECT_DELETE
IS 'Delete ocurrences on MO_ASPECT based on array of MO_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_CREATE(
  INOUT P_MO_RELATIONSHIP MO_RELATIONSHIP_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_MO_RELATIONSHIP.MOR_ID := NEXTVAL('MO_RELATIONSHIP_SEQ');
  INSERT INTO MO_RELATIONSHIP(
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE)
  VALUES(
    P_MO_RELATIONSHIP.MOR_ID, P_MO_RELATIONSHIP.DESCRIPTION, P_MO_RELATIONSHIP.START_TIME, P_MO_RELATIONSHIP.END_TIME, P_MO_RELATIONSHIP.MO_TARGET, P_MO_RELATIONSHIP.MO_SOURCE);
END;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_CREATE
IS 'Creates one tuple on MO_RELATIONSHIP from a MO_RELATIONSHIP_TYP object';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_CREATE_MANY(
  INOUT P_MO_RELATIONSHIP_A MO_RELATIONSHIP_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MO_RELATIONSHIP_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MO_RELATIONSHIP_A[I].MOR_ID := NEXTVAL('MO_RELATIONSHIP_SEQ');
  END LOOP;
  INSERT INTO MO_RELATIONSHIP(
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE)
  SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM UNNEST(P_MO_RELATIONSHIP_A);
END;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_CREATE_MANY
IS 'Creates tuples on MO_RELATIONSHIP from an array of MO_RELATIONSHIP_TYP objects';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_FIND_BY_ID(
  IN P_MOR_ID INTEGER
) RETURNS SETOF MO_RELATIONSHIP_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP
  WHERE 
    MOR_ID = P_MOR_ID;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_FIND_BY_ID
IS 'Find all ocurrences on MO_RELATIONSHIP based on primary key';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF MO_RELATIONSHIP_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_FIND_BY_NAME
IS 'Find all ocurrences on MO_RELATIONSHIP based on name or description';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MO_RELATIONSHIP;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_COUNT
IS 'Counts ocurrences on MO_RELATIONSHIP';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_FIND_ALL() 
RETURNS SETOF MO_RELATIONSHIP_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_FIND_ALL()
IS 'Find all ocurrences on MO_RELATIONSHIP';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MO_RELATIONSHIP;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_DELETE_ALL()
IS 'Delete all ocurrences on MO_RELATIONSHIP';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_DELETE_BY_ID(
  IN P_MOR_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MO_RELATIONSHIP
  WHERE 
    MOR_ID = P_MOR_ID;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_DELETE_BY_ID
IS 'Delete ocurrences on MO_RELATIONSHIP based on primary key';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MO_RELATIONSHIP
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_DELETE_BY_NAME
IS 'Delete ocurrences on MO_RELATIONSHIP based on name';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_UPDATE(
  IN P_MO_RELATIONSHIP_A MO_RELATIONSHIP_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MO_RELATIONSHIP E
  SET 
    MOR_ID=P.MOR_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME, 
    MO_TARGET=P.MO_TARGET, 
    MO_SOURCE=P.MO_SOURCE
  FROM UNNEST(P_MO_RELATIONSHIP_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_UPDATE
IS 'Updates all ocurrences on MO_RELATIONSHIP based on array of MO_RELATIONSHIP_TYP objects';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_DELETE(
  IN P_MO_RELATIONSHIP_A MO_RELATIONSHIP_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MO_RELATIONSHIP T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_RELATIONSHIP_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID);
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_DELETE
IS 'Delete ocurrences on MO_RELATIONSHIP based on array of MO_RELATIONSHIP_TYP objects';

CREATE OR REPLACE PROCEDURE MO_TYPE_CREATE(
  INOUT P_MO_TYPE MO_TYPE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_MO_TYPE.MO_TYPE_ID := NEXTVAL('MO_TYPE_SEQ');
  INSERT INTO MO_TYPE(
    MO_TYPE_ID, DESCRIPTION)
  VALUES(
    P_MO_TYPE.MO_TYPE_ID, P_MO_TYPE.DESCRIPTION);
END;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_CREATE
IS 'Creates one tuple on MO_TYPE from a MO_TYPE_TYP object';

CREATE OR REPLACE PROCEDURE MO_TYPE_CREATE_MANY(
  INOUT P_MO_TYPE_A MO_TYPE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MO_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MO_TYPE_A[I].MO_TYPE_ID := NEXTVAL('MO_TYPE_SEQ');
  END LOOP;
  INSERT INTO MO_TYPE(
    MO_TYPE_ID, DESCRIPTION)
  SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM UNNEST(P_MO_TYPE_A);
END;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_CREATE_MANY
IS 'Creates tuples on MO_TYPE from an array of MO_TYPE_TYP objects';

CREATE OR REPLACE FUNCTION MO_TYPE_FIND_BY_ID(
  IN P_MO_TYPE_ID INTEGER
) RETURNS SETOF MO_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE
  WHERE 
    MO_TYPE_ID = P_MO_TYPE_ID;
$BODY$;

COMMENT ON FUNCTION MO_TYPE_FIND_BY_ID
IS 'Find all ocurrences on MO_TYPE based on primary key';

CREATE OR REPLACE FUNCTION MO_TYPE_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF MO_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION MO_TYPE_FIND_BY_NAME
IS 'Find all ocurrences on MO_TYPE based on name or description';

CREATE OR REPLACE FUNCTION MO_TYPE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MO_TYPE;
$BODY$;

COMMENT ON FUNCTION MO_TYPE_COUNT
IS 'Counts ocurrences on MO_TYPE';

CREATE OR REPLACE FUNCTION MO_TYPE_FIND_ALL() 
RETURNS SETOF MO_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE;
$BODY$;

COMMENT ON FUNCTION MO_TYPE_FIND_ALL()
IS 'Find all ocurrences on MO_TYPE';

CREATE OR REPLACE PROCEDURE MO_TYPE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MO_TYPE;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_DELETE_ALL()
IS 'Delete all ocurrences on MO_TYPE';

CREATE OR REPLACE PROCEDURE MO_TYPE_DELETE_BY_ID(
  IN P_MO_TYPE_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MO_TYPE
  WHERE 
    MO_TYPE_ID = P_MO_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_DELETE_BY_ID
IS 'Delete ocurrences on MO_TYPE based on primary key';

CREATE OR REPLACE PROCEDURE MO_TYPE_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MO_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_DELETE_BY_NAME
IS 'Delete ocurrences on MO_TYPE based on name';

CREATE OR REPLACE PROCEDURE MO_TYPE_UPDATE(
  IN P_MO_TYPE_A MO_TYPE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MO_TYPE E
  SET 
    MO_TYPE_ID=P.MO_TYPE_ID, 
    DESCRIPTION=P.DESCRIPTION
  FROM UNNEST(P_MO_TYPE_A) P
  WHERE 
    E.MO_TYPE_ID = P.MO_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_UPDATE
IS 'Updates all ocurrences on MO_TYPE based on array of MO_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE MO_TYPE_DELETE(
  IN P_MO_TYPE_A MO_TYPE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MO_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_TYPE_A) P
    WHERE 
      P.MO_TYPE_ID = T.MO_TYPE_ID);
$BODY$;

COMMENT ON PROCEDURE MO_TYPE_DELETE
IS 'Delete ocurrences on MO_TYPE based on array of MO_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_CREATE(
  INOUT P_MOR_ASPECT MOR_ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOR_ASPECT(
    MOR_ID, ASPECT_ID)
  VALUES(
    P_MOR_ASPECT.MOR_ID, P_MOR_ASPECT.ASPECT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_CREATE
IS 'Creates one tuple on MOR_ASPECT from a MOR_ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_CREATE_MANY(
  INOUT P_MOR_ASPECT_A MOR_ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOR_ASPECT(
    MOR_ID, ASPECT_ID)
  SELECT
    MOR_ID, ASPECT_ID
  FROM UNNEST(P_MOR_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_CREATE_MANY
IS 'Creates tuples on MOR_ASPECT from an array of MOR_ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION MOR_ASPECT_FIND_BY_ID(
  IN P_MOR_ID INTEGER,
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF MOR_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, ASPECT_ID
  FROM MOR_ASPECT
  WHERE 
    MOR_ID = P_MOR_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION MOR_ASPECT_FIND_BY_ID
IS 'Find all ocurrences on MOR_ASPECT based on primary key';

CREATE OR REPLACE FUNCTION MOR_ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MOR_ASPECT;
$BODY$;

COMMENT ON FUNCTION MOR_ASPECT_COUNT
IS 'Counts ocurrences on MOR_ASPECT';

CREATE OR REPLACE FUNCTION MOR_ASPECT_FIND_ALL() 
RETURNS SETOF MOR_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, ASPECT_ID
  FROM MOR_ASPECT;
$BODY$;

COMMENT ON FUNCTION MOR_ASPECT_FIND_ALL()
IS 'Find all ocurrences on MOR_ASPECT';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MOR_ASPECT;
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on MOR_ASPECT';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_DELETE_BY_ID(
  IN P_MOR_ID INTEGER,
  IN P_ASPECT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MOR_ASPECT
  WHERE 
    MOR_ID = P_MOR_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_DELETE_BY_ID
IS 'Delete ocurrences on MOR_ASPECT based on primary key';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_UPDATE(
  IN P_MOR_ASPECT_A MOR_ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MOR_ASPECT E
  SET 
    MOR_ID=P.MOR_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_MOR_ASPECT_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID AND
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_UPDATE
IS 'Updates all ocurrences on MOR_ASPECT based on array of MOR_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MOR_ASPECT_DELETE(
  IN P_MOR_ASPECT_A MOR_ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MOR_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOR_ASPECT_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID AND
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE MOR_ASPECT_DELETE
IS 'Delete ocurrences on MOR_ASPECT based on array of MOR_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_CREATE(
  INOUT P_MOVING_OBJECT MOVING_OBJECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_MOVING_OBJECT.MO_ID := NEXTVAL('MOVING_OBJECT_SEQ');
  INSERT INTO MOVING_OBJECT(
    MO_ID, DESCRIPTION, MO_TYPE_ID)
  VALUES(
    P_MOVING_OBJECT.MO_ID, P_MOVING_OBJECT.DESCRIPTION, P_MOVING_OBJECT.MO_TYPE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_CREATE
IS 'Creates one tuple on MOVING_OBJECT from a MOVING_OBJECT_TYP object';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_CREATE_MANY(
  INOUT P_MOVING_OBJECT_A MOVING_OBJECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MOVING_OBJECT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MOVING_OBJECT_A[I].MO_ID := NEXTVAL('MOVING_OBJECT_SEQ');
  END LOOP;
  INSERT INTO MOVING_OBJECT(
    MO_ID, DESCRIPTION, MO_TYPE_ID)
  SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM UNNEST(P_MOVING_OBJECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_CREATE_MANY
IS 'Creates tuples on MOVING_OBJECT from an array of MOVING_OBJECT_TYP objects';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_FIND_BY_ID(
  IN P_MO_ID INTEGER
) RETURNS SETOF MOVING_OBJECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT
  WHERE 
    MO_ID = P_MO_ID;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_FIND_BY_ID
IS 'Find all ocurrences on MOVING_OBJECT based on primary key';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF MOVING_OBJECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_FIND_BY_NAME
IS 'Find all ocurrences on MOVING_OBJECT based on name or description';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MOVING_OBJECT;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_COUNT
IS 'Counts ocurrences on MOVING_OBJECT';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_FIND_ALL() 
RETURNS SETOF MOVING_OBJECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_FIND_ALL()
IS 'Find all ocurrences on MOVING_OBJECT';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MOVING_OBJECT;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_DELETE_ALL()
IS 'Delete all ocurrences on MOVING_OBJECT';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_DELETE_BY_ID(
  IN P_MO_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MOVING_OBJECT
  WHERE 
    MO_ID = P_MO_ID;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_DELETE_BY_ID
IS 'Delete ocurrences on MOVING_OBJECT based on primary key';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_DELETE_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM MOVING_OBJECT
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_DELETE_BY_NAME
IS 'Delete ocurrences on MOVING_OBJECT based on name';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_UPDATE(
  IN P_MOVING_OBJECT_A MOVING_OBJECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MOVING_OBJECT E
  SET 
    MO_ID=P.MO_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    MO_TYPE_ID=P.MO_TYPE_ID
  FROM UNNEST(P_MOVING_OBJECT_A) P
  WHERE 
    E.MO_ID = P.MO_ID;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_UPDATE
IS 'Updates all ocurrences on MOVING_OBJECT based on array of MOVING_OBJECT_TYP objects';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_DELETE(
  IN P_MOVING_OBJECT_A MOVING_OBJECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MOVING_OBJECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOVING_OBJECT_A) P
    WHERE 
      P.MO_ID = T.MO_ID);
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_DELETE
IS 'Delete ocurrences on MOVING_OBJECT based on array of MOVING_OBJECT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_CREATE(
  INOUT P_POINT POINT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_POINT.POINT_ID := NEXTVAL('POINT_SEQ');
  INSERT INTO POINT(
    POINT_ID, P_ORDER, MAT_ID, T)
  VALUES(
    P_POINT.POINT_ID, P_POINT.P_ORDER, P_POINT.MAT_ID, P_POINT.T);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_CREATE
IS 'Creates one tuple on POINT from a POINT_TYP object';

CREATE OR REPLACE PROCEDURE POINT_CREATE_MANY(
  INOUT P_POINT_A POINT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_POINT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_POINT_A[I].POINT_ID := NEXTVAL('POINT_SEQ');
  END LOOP;
  INSERT INTO POINT(
    POINT_ID, P_ORDER, MAT_ID, T)
  SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM UNNEST(P_POINT_A);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_CREATE_MANY
IS 'Creates tuples on POINT from an array of POINT_TYP objects';

CREATE OR REPLACE FUNCTION POINT_FIND_BY_ID(
  IN P_POINT_ID INTEGER
) RETURNS SETOF POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM POINT
  WHERE 
    POINT_ID = P_POINT_ID;
$BODY$;

COMMENT ON FUNCTION POINT_FIND_BY_ID
IS 'Find all ocurrences on POINT based on primary key';

CREATE OR REPLACE FUNCTION POINT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM POINT;
$BODY$;

COMMENT ON FUNCTION POINT_COUNT
IS 'Counts ocurrences on POINT';

CREATE OR REPLACE FUNCTION POINT_FIND_ALL() 
RETURNS SETOF POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM POINT;
$BODY$;

COMMENT ON FUNCTION POINT_FIND_ALL()
IS 'Find all ocurrences on POINT';

CREATE OR REPLACE PROCEDURE POINT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM POINT;
$BODY$;

COMMENT ON PROCEDURE POINT_DELETE_ALL()
IS 'Delete all ocurrences on POINT';

CREATE OR REPLACE PROCEDURE POINT_DELETE_BY_ID(
  IN P_POINT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM POINT
  WHERE 
    POINT_ID = P_POINT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_DELETE_BY_ID
IS 'Delete ocurrences on POINT based on primary key';

CREATE OR REPLACE PROCEDURE POINT_UPDATE(
  IN P_POINT_A POINT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE POINT E
  SET 
    POINT_ID=P.POINT_ID, 
    P_ORDER=P.P_ORDER, 
    MAT_ID=P.MAT_ID, 
    T=P.T
  FROM UNNEST(P_POINT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_UPDATE
IS 'Updates all ocurrences on POINT based on array of POINT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_DELETE(
  IN P_POINT_A POINT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID);
$BODY$;

COMMENT ON PROCEDURE POINT_DELETE
IS 'Delete ocurrences on POINT based on array of POINT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_CREATE(
  INOUT P_POINT_ASPECT POINT_ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_ASPECT(
    POINT_ID, ASPECT_ID)
  VALUES(
    P_POINT_ASPECT.POINT_ID, P_POINT_ASPECT.ASPECT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_CREATE
IS 'Creates one tuple on POINT_ASPECT from a POINT_ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_CREATE_MANY(
  INOUT P_POINT_ASPECT_A POINT_ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_ASPECT(
    POINT_ID, ASPECT_ID)
  SELECT
    POINT_ID, ASPECT_ID
  FROM UNNEST(P_POINT_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_CREATE_MANY
IS 'Creates tuples on POINT_ASPECT from an array of POINT_ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION POINT_ASPECT_FIND_BY_ID(
  IN P_POINT_ID INTEGER,
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF POINT_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, ASPECT_ID
  FROM POINT_ASPECT
  WHERE 
    POINT_ID = P_POINT_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION POINT_ASPECT_FIND_BY_ID
IS 'Find all ocurrences on POINT_ASPECT based on primary key';

CREATE OR REPLACE FUNCTION POINT_ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM POINT_ASPECT;
$BODY$;

COMMENT ON FUNCTION POINT_ASPECT_COUNT
IS 'Counts ocurrences on POINT_ASPECT';

CREATE OR REPLACE FUNCTION POINT_ASPECT_FIND_ALL() 
RETURNS SETOF POINT_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, ASPECT_ID
  FROM POINT_ASPECT;
$BODY$;

COMMENT ON FUNCTION POINT_ASPECT_FIND_ALL()
IS 'Find all ocurrences on POINT_ASPECT';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM POINT_ASPECT;
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on POINT_ASPECT';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_DELETE_BY_ID(
  IN P_POINT_ID INTEGER,
  IN P_ASPECT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM POINT_ASPECT
  WHERE 
    POINT_ID = P_POINT_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_DELETE_BY_ID
IS 'Delete ocurrences on POINT_ASPECT based on primary key';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_UPDATE(
  IN P_POINT_ASPECT_A POINT_ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE POINT_ASPECT E
  SET 
    POINT_ID=P.POINT_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_POINT_ASPECT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_UPDATE
IS 'Updates all ocurrences on POINT_ASPECT based on array of POINT_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_ASPECT_DELETE(
  IN P_POINT_ASPECT_A POINT_ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    POINT_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_ASPECT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE POINT_ASPECT_DELETE
IS 'Delete ocurrences on POINT_ASPECT based on array of POINT_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_CREATE(
  INOUT P_POINT_REPR_POINT POINT_REPR_POINT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_REPR_POINT(
    POINT_ID, REPR_POINT_ID)
  VALUES(
    P_POINT_REPR_POINT.POINT_ID, P_POINT_REPR_POINT.REPR_POINT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_CREATE
IS 'Creates one tuple on POINT_REPR_POINT from a POINT_REPR_POINT_TYP object';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_CREATE_MANY(
  INOUT P_POINT_REPR_POINT_A POINT_REPR_POINT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_REPR_POINT(
    POINT_ID, REPR_POINT_ID)
  SELECT
    POINT_ID, REPR_POINT_ID
  FROM UNNEST(P_POINT_REPR_POINT_A);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_CREATE_MANY
IS 'Creates tuples on POINT_REPR_POINT from an array of POINT_REPR_POINT_TYP objects';

CREATE OR REPLACE FUNCTION POINT_REPR_POINT_FIND_BY_ID(
  IN P_POINT_ID INTEGER,
  IN P_REPR_POINT_ID INTEGER
) RETURNS SETOF POINT_REPR_POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, REPR_POINT_ID
  FROM POINT_REPR_POINT
  WHERE 
    POINT_ID = P_POINT_ID AND
    REPR_POINT_ID = P_REPR_POINT_ID;
$BODY$;

COMMENT ON FUNCTION POINT_REPR_POINT_FIND_BY_ID
IS 'Find all ocurrences on POINT_REPR_POINT based on primary key';

CREATE OR REPLACE FUNCTION POINT_REPR_POINT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM POINT_REPR_POINT;
$BODY$;

COMMENT ON FUNCTION POINT_REPR_POINT_COUNT
IS 'Counts ocurrences on POINT_REPR_POINT';

CREATE OR REPLACE FUNCTION POINT_REPR_POINT_FIND_ALL() 
RETURNS SETOF POINT_REPR_POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, REPR_POINT_ID
  FROM POINT_REPR_POINT;
$BODY$;

COMMENT ON FUNCTION POINT_REPR_POINT_FIND_ALL()
IS 'Find all ocurrences on POINT_REPR_POINT';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM POINT_REPR_POINT;
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_DELETE_ALL()
IS 'Delete all ocurrences on POINT_REPR_POINT';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_UPDATE(
  IN P_POINT_REPR_POINT_A POINT_REPR_POINT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE POINT_REPR_POINT E
  SET 
    POINT_ID=P.POINT_ID, 
    REPR_POINT_ID=P.REPR_POINT_ID
  FROM UNNEST(P_POINT_REPR_POINT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.REPR_POINT_ID = P.REPR_POINT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_UPDATE
IS 'Updates all ocurrences on POINT_REPR_POINT based on array of POINT_REPR_POINT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_DELETE(
  IN P_POINT_REPR_POINT_A POINT_REPR_POINT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    POINT_REPR_POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_REPR_POINT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.REPR_POINT_ID = T.REPR_POINT_ID);
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_DELETE
IS 'Delete ocurrences on POINT_REPR_POINT based on array of POINT_REPR_POINT_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_REPR_POINT_DELETE_BY_ID(
  IN P_POINT_ID INTEGER,
  IN P_REPR_POINT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM POINT_REPR_POINT
  WHERE 
    POINT_ID = P_POINT_ID AND
    REPR_POINT_ID = P_REPR_POINT_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_REPR_POINT_DELETE_BY_ID
IS 'Delete ocurrences on POINT_REPR_POINT based on primary key';

CREATE OR REPLACE PROCEDURE REPR_POINT_CREATE(
  INOUT P_REPR_POINT REPR_POINT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO REPR_POINT(
    REPR_POINT_ID)
  VALUES(
    P_REPR_POINT.REPR_POINT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_CREATE
IS 'Creates one tuple on REPR_POINT from a REPR_POINT_TYP object';

CREATE OR REPLACE PROCEDURE REPR_POINT_CREATE_MANY(
  INOUT P_REPR_POINT_A REPR_POINT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO REPR_POINT(
    REPR_POINT_ID)
  SELECT
    REPR_POINT_ID
  FROM UNNEST(P_REPR_POINT_A);
END;
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_CREATE_MANY
IS 'Creates tuples on REPR_POINT from an array of REPR_POINT_TYP objects';

CREATE OR REPLACE FUNCTION REPR_POINT_FIND_BY_ID(
  IN P_REPR_POINT_ID INTEGER
) RETURNS SETOF REPR_POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    REPR_POINT_ID
  FROM REPR_POINT
  WHERE 
    REPR_POINT_ID = P_REPR_POINT_ID;
$BODY$;

COMMENT ON FUNCTION REPR_POINT_FIND_BY_ID
IS 'Find all ocurrences on REPR_POINT based on primary key';

CREATE OR REPLACE FUNCTION REPR_POINT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM REPR_POINT;
$BODY$;

COMMENT ON FUNCTION REPR_POINT_COUNT
IS 'Counts ocurrences on REPR_POINT';

CREATE OR REPLACE FUNCTION REPR_POINT_FIND_ALL() 
RETURNS SETOF REPR_POINT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    REPR_POINT_ID
  FROM REPR_POINT;
$BODY$;

COMMENT ON FUNCTION REPR_POINT_FIND_ALL()
IS 'Find all ocurrences on REPR_POINT';

CREATE OR REPLACE PROCEDURE REPR_POINT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM REPR_POINT;
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_DELETE_ALL()
IS 'Delete all ocurrences on REPR_POINT';

CREATE OR REPLACE PROCEDURE REPR_POINT_DELETE_BY_ID(
  IN P_REPR_POINT_ID INTEGER
)
LANGUAGE SQL AS 
$BODY$
  DELETE
  FROM REPR_POINT
  WHERE 
    REPR_POINT_ID = P_REPR_POINT_ID;
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_DELETE_BY_ID
IS 'Delete ocurrences on REPR_POINT based on primary key';

CREATE OR REPLACE PROCEDURE REPR_POINT_UPDATE(
  IN P_REPR_POINT_A REPR_POINT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE REPR_POINT E
  SET 
    REPR_POINT_ID=P.REPR_POINT_ID
  FROM UNNEST(P_REPR_POINT_A) P
  WHERE 
    E.REPR_POINT_ID = P.REPR_POINT_ID;
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_UPDATE
IS 'Updates all ocurrences on REPR_POINT based on array of REPR_POINT_TYP objects';

CREATE OR REPLACE PROCEDURE REPR_POINT_DELETE(
  IN P_REPR_POINT_A REPR_POINT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    REPR_POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_REPR_POINT_A) P
    WHERE 
      P.REPR_POINT_ID = T.REPR_POINT_ID);
$BODY$;

COMMENT ON PROCEDURE REPR_POINT_DELETE
IS 'Delete ocurrences on REPR_POINT based on array of REPR_POINT_TYP objects';


SET SEARCH_PATH TO MASTER, public ;


CREATE TABLE MASTER.DATASET
(
	DATASET_ID           INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	URL                  VARCHAR(250) NOT NULL
);

ALTER TABLE MASTER.DATASET
ADD PRIMARY KEY (DATASET_ID);

CREATE SEQUENCE IF NOT EXISTS DATASET_SEQ ;


CREATE TYPE DATASET_TYP AS (
  DATASET_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  URL VARCHAR(250));


CREATE TABLE MASTER.DEPENDENCY_RULE
(
	RULE_ID              INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	START_TIME           TIMESTAMP NOT NULL,
	END_TIME             TIMESTAMP NULL,
	CONFIDENCE           INTEGER NOT NULL,
	DR_TYPE              INTEGER NOT NULL
);

ALTER TABLE MASTER.DEPENDENCY_RULE
ADD PRIMARY KEY (RULE_ID);

CREATE SEQUENCE IF NOT EXISTS DEPENDENCY_RULE_SEQ ;


CREATE TYPE DEPENDENCY_RULE_TYP AS (
  RULE_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  START_TIME TIMESTAMP,
  END_TIME TIMESTAMP,
  CONFIDENCE INTEGER,
  DR_TYPE INTEGER);


CREATE TABLE MASTER.DEPENDENCY_RULE_DATASET
(
	RULE_ID              INTEGER NOT NULL,
	DATASET_ID           INTEGER NOT NULL
);

ALTER TABLE MASTER.DEPENDENCY_RULE_DATASET
ADD PRIMARY KEY (RULE_ID,DATASET_ID);

CREATE INDEX XIF1DEPENDENCY_RULE_DATASET ON DEPENDENCY_RULE_DATASET
(
	RULE_ID
);

CREATE INDEX XIF2DEPENDENCY_RULE_DATASET ON DEPENDENCY_RULE_DATASET
(
	DATASET_ID
);

CREATE TYPE DEPENDENCY_RULE_DATASET_TYP AS (
  RULE_ID INTEGER,
  DATASET_ID INTEGER);


CREATE TABLE MASTER.MAT_DR
(
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MAT_DR
ADD PRIMARY KEY (RULE_ID);

CREATE UNIQUE INDEX XIF1MAT_DR ON MAT_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MAT_DR_SEQ ;


CREATE TYPE MAT_DR_TYP AS (
  RULE_ID INTEGER);


CREATE TABLE MASTER.MAT_MAT_DR
(
	MAT_ID               INTEGER NOT NULL,
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MAT_MAT_DR
ADD PRIMARY KEY (MAT_ID,RULE_ID);

CREATE INDEX XIF1MAT_MAT_DR ON MAT_MAT_DR
(
	MAT_ID
);

CREATE INDEX XIF2MAT_MAT_DR ON MAT_MAT_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MAT_MAT_DR_SEQ ;


CREATE TYPE MAT_MAT_DR_TYP AS (
  MAT_ID INTEGER,
  RULE_ID INTEGER);


CREATE TABLE MASTER.MO_DR
(
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MO_DR
ADD PRIMARY KEY (RULE_ID);

CREATE UNIQUE INDEX XIF1MO_DR ON MO_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MO_DR_SEQ ;


CREATE TYPE MO_DR_TYP AS (
  RULE_ID INTEGER);


CREATE TABLE MASTER.MO_RELATIONSHIP_MOR_DR
(
	MOR_ID               INTEGER NOT NULL,
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MO_RELATIONSHIP_MOR_DR
ADD PRIMARY KEY (MOR_ID,RULE_ID);

CREATE INDEX XIF1MO_RELATIONSHIP_MOR_DR ON MO_RELATIONSHIP_MOR_DR
(
	MOR_ID
);

CREATE INDEX XIF2MO_RELATIONSHIP_MOR_DR ON MO_RELATIONSHIP_MOR_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MO_RELATIONSHIP_MOR_DR_SEQ ;


CREATE TYPE MO_RELATIONSHIP_MOR_DR_TYP AS (
  MOR_ID INTEGER,
  RULE_ID INTEGER);


CREATE TABLE MASTER.MOR_DR
(
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MOR_DR
ADD PRIMARY KEY (RULE_ID);

CREATE UNIQUE INDEX XIF1MOR_DR ON MOR_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MOR_DR_SEQ ;


CREATE TYPE MOR_DR_TYP AS (
  RULE_ID INTEGER);


CREATE TABLE MASTER.MOVING_OBJECT_MO_DR
(
	MO_ID                INTEGER NOT NULL,
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.MOVING_OBJECT_MO_DR
ADD PRIMARY KEY (MO_ID,RULE_ID);

CREATE INDEX XIF1MOVING_OBJECT_MO_DR ON MOVING_OBJECT_MO_DR
(
	MO_ID
);

CREATE INDEX XIF2MOVING_OBJECT_MO_DR ON MOVING_OBJECT_MO_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS MOVING_OBJECT_MO_DR_SEQ ;


CREATE TYPE MOVING_OBJECT_MO_DR_TYP AS (
  MO_ID INTEGER,
  RULE_ID INTEGER);


CREATE TABLE MASTER.POINT_DR
(
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.POINT_DR
ADD PRIMARY KEY (RULE_ID);

CREATE UNIQUE INDEX XIF1POINT_DR ON POINT_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS POINT_DR_SEQ ;


CREATE TYPE POINT_DR_TYP AS (
  RULE_ID INTEGER);


CREATE TABLE MASTER.POINT_POINT_DR
(
	POINT_ID             INTEGER NOT NULL,
	RULE_ID              INTEGER NOT NULL
);

ALTER TABLE MASTER.POINT_POINT_DR
ADD PRIMARY KEY (POINT_ID,RULE_ID);

CREATE INDEX XIF1POINT_POINT_DR ON POINT_POINT_DR
(
	POINT_ID
);

CREATE INDEX XIF2POINT_POINT_DR ON POINT_POINT_DR
(
	RULE_ID
);

CREATE SEQUENCE IF NOT EXISTS POINT_POINT_DR_SEQ ;


CREATE TYPE POINT_POINT_DR_TYP AS (
  POINT_ID INTEGER,
  RULE_ID INTEGER);


CREATE TABLE MASTER.PREDICATE
(
	PREDICATE_ID         INTEGER NOT NULL,
	DESCRIPTION          VARCHAR(50) NOT NULL,
	PREDICATE_ORDER      INTEGER NOT NULL,
	PREDICATE_PATH       VARCHAR(250) NOT NULL,
	PARENTHESIS_TYPE     INTEGER NOT NULL,
	PARENTHESIS_AMOUNT   FLOAT NOT NULL,
	LOGICAL_OPERATOR     VARCHAR(20) NOT NULL,
	DETERMINED           INTEGER NOT NULL,
	DETERMINANT          INTEGER NOT NULL
);

ALTER TABLE MASTER.PREDICATE
ADD PRIMARY KEY (PREDICATE_ID);

CREATE INDEX XIF1PREDICATE ON PREDICATE
(
	DETERMINED
);

CREATE INDEX XIF2PREDICATE ON PREDICATE
(
	DETERMINANT
);

CREATE SEQUENCE IF NOT EXISTS PREDICATE_SEQ ;


CREATE TYPE PREDICATE_TYP AS (
  PREDICATE_ID INTEGER,
  DESCRIPTION VARCHAR(50),
  PREDICATE_ORDER INTEGER,
  PREDICATE_PATH VARCHAR(250),
  PARENTHESIS_TYPE INTEGER,
  PARENTHESIS_AMOUNT FLOAT,
  LOGICAL_OPERATOR VARCHAR(20),
  DETERMINANT INTEGER,
  DETERMINED INTEGER);


CREATE TABLE MASTER.PREDICATE_ASPECT
(
	PREDICATE_ID         INTEGER NOT NULL,
	ASPECT_ID            INTEGER NOT NULL
);

ALTER TABLE MASTER.PREDICATE_ASPECT
ADD PRIMARY KEY (PREDICATE_ID,ASPECT_ID);

CREATE INDEX XIF1PREDICATE_ASPECT ON PREDICATE_ASPECT
(
	PREDICATE_ID
);

CREATE INDEX XIF2PREDICATE_ASPECT ON PREDICATE_ASPECT
(
	ASPECT_ID
);

CREATE SEQUENCE IF NOT EXISTS PREDICATE_ASPECT_SEQ ;


CREATE TYPE PREDICATE_ASPECT_TYP AS (
  PREDICATE_ID INTEGER,
  ASPECT_ID INTEGER);


CREATE TABLE MASTER.PREDICATE_ASPECT_TYPE
(
	PREDICATE_ID         INTEGER NOT NULL,
	ASPECT_TYPE_ID       INTEGER NOT NULL
);

ALTER TABLE MASTER.PREDICATE_ASPECT_TYPE
ADD PRIMARY KEY (PREDICATE_ID,ASPECT_TYPE_ID);

CREATE INDEX XIF1PREDICATE_ASPECT_TYPE ON PREDICATE_ASPECT_TYPE
(
	PREDICATE_ID
);

CREATE INDEX XIF2PREDICATE_ASPECT_TYPE ON PREDICATE_ASPECT_TYPE
(
	ASPECT_TYPE_ID
);

CREATE SEQUENCE IF NOT EXISTS PREDICATE_ASPECT_TYPE_SEQ ;


CREATE TYPE PREDICATE_ASPECT_TYPE_TYP AS (
  PREDICATE_ID INTEGER,
  ASPECT_TYPE_ID INTEGER);


ALTER TABLE MASTER.DEPENDENCY_RULE_DATASET
ADD CONSTRAINT R_2 FOREIGN KEY (RULE_ID) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.DEPENDENCY_RULE_DATASET
ADD CONSTRAINT R_3 FOREIGN KEY (DATASET_ID) REFERENCES MASTER.DATASET (DATASET_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MAT_DR
ADD CONSTRAINT R_36 FOREIGN KEY (RULE_ID) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MAT_MAT_DR
ADD CONSTRAINT R_45 FOREIGN KEY (MAT_ID) REFERENCES MASTER.MAT (MAT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MAT_MAT_DR
ADD CONSTRAINT R_46 FOREIGN KEY (RULE_ID) REFERENCES MASTER.MAT_DR (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_DR
ADD CONSTRAINT R_35 FOREIGN KEY (RULE_ID) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_RELATIONSHIP_MOR_DR
ADD CONSTRAINT R_39 FOREIGN KEY (MOR_ID) REFERENCES MASTER.MO_RELATIONSHIP (MOR_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MO_RELATIONSHIP_MOR_DR
ADD CONSTRAINT R_40 FOREIGN KEY (RULE_ID) REFERENCES MASTER.MOR_DR (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MOR_DR
ADD CONSTRAINT R_34 FOREIGN KEY (RULE_ID) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MOVING_OBJECT_MO_DR
ADD CONSTRAINT R_42 FOREIGN KEY (MO_ID) REFERENCES MASTER.MOVING_OBJECT (MO_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.MOVING_OBJECT_MO_DR
ADD CONSTRAINT R_43 FOREIGN KEY (RULE_ID) REFERENCES MASTER.MO_DR (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_DR
ADD CONSTRAINT R_37 FOREIGN KEY (RULE_ID) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_POINT_DR
ADD CONSTRAINT R_48 FOREIGN KEY (POINT_ID) REFERENCES MASTER.POINT (POINT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.POINT_POINT_DR
ADD CONSTRAINT R_49 FOREIGN KEY (RULE_ID) REFERENCES MASTER.POINT_DR (RULE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.PREDICATE
ADD CONSTRAINT R_4 FOREIGN KEY (DETERMINED) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID);

ALTER TABLE MASTER.PREDICATE
ADD CONSTRAINT R_5 FOREIGN KEY (DETERMINANT) REFERENCES MASTER.DEPENDENCY_RULE (RULE_ID);

ALTER TABLE MASTER.PREDICATE_ASPECT
ADD CONSTRAINT R_51 FOREIGN KEY (PREDICATE_ID) REFERENCES MASTER.PREDICATE (PREDICATE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.PREDICATE_ASPECT
ADD CONSTRAINT R_52 FOREIGN KEY (ASPECT_ID) REFERENCES MASTER.ASPECT (ASPECT_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.PREDICATE_ASPECT_TYPE
ADD CONSTRAINT R_54 FOREIGN KEY (PREDICATE_ID) REFERENCES MASTER.PREDICATE (PREDICATE_ID)
		ON DELETE CASCADE;

ALTER TABLE MASTER.PREDICATE_ASPECT_TYPE
ADD CONSTRAINT R_55 FOREIGN KEY (ASPECT_TYPE_ID) REFERENCES MASTER.ASPECT_TYPE (ASPECT_TYPE_ID)
		ON DELETE CASCADE;

CREATE OR REPLACE PROCEDURE DATASET_CREATE(
  INOUT P_DATASET DATASET_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_DATASET.DATASET_ID := NEXTVAL('DATASET_SEQ');
  INSERT INTO DATASET(
    DATASET_ID, DESCRIPTION, URL)
  VALUES(
    P_DATASET.DATASET_ID, P_DATASET.DESCRIPTION, P_DATASET.URL);
END;
$BODY$;

COMMENT ON PROCEDURE DATASET_CREATE
IS 'Creates one tuple on DATASET from a DATASET_TYP object';

CREATE OR REPLACE PROCEDURE DATASET_CREATE_MANY(
  INOUT P_DATASET_A DATASET_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DATASET_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DATASET_A[I].DATASET_ID := NEXTVAL('DATASET_SEQ');
  END LOOP;
  INSERT INTO DATASET(
    DATASET_ID, DESCRIPTION, URL)
  SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM UNNEST(P_DATASET_A);
END;
$BODY$;

COMMENT ON PROCEDURE DATASET_CREATE_MANY
IS 'Creates tuples on DATASET from an array of DATASET_TYP objects';

CREATE OR REPLACE FUNCTION DATASET_FIND_BY_ID(
  IN P_DATASET_ID INTEGER
) RETURNS SETOF DATASET_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET
  WHERE 
    DATASET_ID = P_DATASET_ID;
$BODY$;

COMMENT ON FUNCTION DATASET_FIND_BY_ID
IS 'Find all ocurrences on DATASET based on primary key';

CREATE OR REPLACE FUNCTION DATASET_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM DATASET;
$BODY$;

COMMENT ON FUNCTION DATASET_COUNT
IS 'Counts ocurrences on DATASET';

CREATE OR REPLACE FUNCTION DATASET_FIND_ALL() 
RETURNS SETOF DATASET_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET;
$BODY$;

COMMENT ON FUNCTION DATASET_FIND_ALL()
IS 'Find all ocurrences on DATASET';

CREATE OR REPLACE PROCEDURE DATASET_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM DATASET;
$BODY$;

COMMENT ON PROCEDURE DATASET_DELETE_ALL()
IS 'Delete all ocurrences on DATASET';

CREATE OR REPLACE PROCEDURE DATASET_UPDATE(
  IN P_DATASET_A DATASET_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE DATASET E
  SET 
    DATASET_ID=P.DATASET_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    URL=P.URL
  FROM UNNEST(P_DATASET_A) P
  WHERE 
    E.DATASET_ID = P.DATASET_ID;
$BODY$;

COMMENT ON PROCEDURE DATASET_UPDATE
IS 'Updates all ocurrences on DATASET based on array of DATASET_TYP objects';

CREATE OR REPLACE PROCEDURE DATASET_DELETE(
  IN P_DATASET_A DATASET_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    DATASET T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DATASET_A) P
    WHERE 
      P.DATASET_ID = T.DATASET_ID);
$BODY$;

COMMENT ON PROCEDURE DATASET_DELETE
IS 'Delete ocurrences on DATASET based on array of DATASET_TYP objects';

CREATE OR REPLACE FUNCTION DATASET_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF DATASET_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION DATASET_FIND_BY_NAME
IS 'Find all ocurrences on DATASET based on name or description';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_CREATE(
  INOUT P_DEPENDENCY_RULE DEPENDENCY_RULE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_DEPENDENCY_RULE.RULE_ID := NEXTVAL('DEPENDENCY_RULE_SEQ');
  INSERT INTO DEPENDENCY_RULE(
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE)
  VALUES(
    P_DEPENDENCY_RULE.RULE_ID, P_DEPENDENCY_RULE.DESCRIPTION, P_DEPENDENCY_RULE.START_TIME, P_DEPENDENCY_RULE.END_TIME, P_DEPENDENCY_RULE.CONFIDENCE, P_DEPENDENCY_RULE.DR_TYPE);
END;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_CREATE
IS 'Creates one tuple on DEPENDENCY_RULE from a DEPENDENCY_RULE_TYP object';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_CREATE_MANY(
  INOUT P_DEPENDENCY_RULE_A DEPENDENCY_RULE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DEPENDENCY_RULE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DEPENDENCY_RULE_A[I].RULE_ID := NEXTVAL('DEPENDENCY_RULE_SEQ');
  END LOOP;
  INSERT INTO DEPENDENCY_RULE(
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE)
  SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM UNNEST(P_DEPENDENCY_RULE_A);
END;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_CREATE_MANY
IS 'Creates tuples on DEPENDENCY_RULE from an array of DEPENDENCY_RULE_TYP objects';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_FIND_BY_ID(
  IN P_RULE_ID INTEGER
) RETURNS SETOF DEPENDENCY_RULE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE
  WHERE 
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_FIND_BY_ID
IS 'Find all ocurrences on DEPENDENCY_RULE based on primary key';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM DEPENDENCY_RULE;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_COUNT
IS 'Counts ocurrences on DEPENDENCY_RULE';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_FIND_ALL() 
RETURNS SETOF DEPENDENCY_RULE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_FIND_ALL()
IS 'Find all ocurrences on DEPENDENCY_RULE';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM DEPENDENCY_RULE;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DELETE_ALL()
IS 'Delete all ocurrences on DEPENDENCY_RULE';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_UPDATE(
  IN P_DEPENDENCY_RULE_A DEPENDENCY_RULE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE DEPENDENCY_RULE E
  SET 
    RULE_ID=P.RULE_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME, 
    CONFIDENCE=P.CONFIDENCE, 
    DR_TYPE=P.DR_TYPE
  FROM UNNEST(P_DEPENDENCY_RULE_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_UPDATE
IS 'Updates all ocurrences on DEPENDENCY_RULE based on array of DEPENDENCY_RULE_TYP objects';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DELETE(
  IN P_DEPENDENCY_RULE_A DEPENDENCY_RULE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    DEPENDENCY_RULE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DEPENDENCY_RULE_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DELETE
IS 'Delete ocurrences on DEPENDENCY_RULE based on array of DEPENDENCY_RULE_TYP objects';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF DEPENDENCY_RULE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_FIND_BY_NAME
IS 'Find all ocurrences on DEPENDENCY_RULE based on name or description';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DATASET_CREATE(
  INOUT P_DEPENDENCY_RULE_DATASET DEPENDENCY_RULE_DATASET_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO DEPENDENCY_RULE_DATASET(
    RULE_ID, DATASET_ID)
  VALUES(
    P_DEPENDENCY_RULE_DATASET.RULE_ID, P_DEPENDENCY_RULE_DATASET.DATASET_ID);
END;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DATASET_CREATE
IS 'Creates one tuple on DEPENDENCY_RULE_DATASET from a DEPENDENCY_RULE_DATASET_TYP object';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DATASET_CREATE_MANY(
  INOUT P_DEPENDENCY_RULE_DATASET_A DEPENDENCY_RULE_DATASET_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO DEPENDENCY_RULE_DATASET(
    RULE_ID, DATASET_ID)
  SELECT
    RULE_ID, DATASET_ID
  FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A);
END;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DATASET_CREATE_MANY
IS 'Creates tuples on DEPENDENCY_RULE_DATASET from an array of DEPENDENCY_RULE_DATASET_TYP objects';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_DATASET_FIND_BY_ID(
  IN P_RULE_ID INTEGER,
  IN P_DATASET_ID INTEGER
) RETURNS SETOF DEPENDENCY_RULE_DATASET_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID, DATASET_ID
  FROM DEPENDENCY_RULE_DATASET
  WHERE 
    RULE_ID = P_RULE_ID AND
    DATASET_ID = P_DATASET_ID;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_DATASET_FIND_BY_ID
IS 'Find all ocurrences on DEPENDENCY_RULE_DATASET based on primary key';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_DATASET_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM DEPENDENCY_RULE_DATASET;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_DATASET_COUNT
IS 'Counts ocurrences on DEPENDENCY_RULE_DATASET';

CREATE OR REPLACE FUNCTION DEPENDENCY_RULE_DATASET_FIND_ALL() 
RETURNS SETOF DEPENDENCY_RULE_DATASET_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID, DATASET_ID
  FROM DEPENDENCY_RULE_DATASET;
$BODY$;

COMMENT ON FUNCTION DEPENDENCY_RULE_DATASET_FIND_ALL()
IS 'Find all ocurrences on DEPENDENCY_RULE_DATASET';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DATASET_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM DEPENDENCY_RULE_DATASET;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DATASET_DELETE_ALL()
IS 'Delete all ocurrences on DEPENDENCY_RULE_DATASET';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DATASET_UPDATE(
  IN P_DEPENDENCY_RULE_DATASET_A DEPENDENCY_RULE_DATASET_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE DEPENDENCY_RULE_DATASET E
  SET 
    RULE_ID=P.RULE_ID, 
    DATASET_ID=P.DATASET_ID
  FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID AND
    E.DATASET_ID = P.DATASET_ID;
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DATASET_UPDATE
IS 'Updates all ocurrences on DEPENDENCY_RULE_DATASET based on array of DEPENDENCY_RULE_DATASET_TYP objects';

CREATE OR REPLACE PROCEDURE DEPENDENCY_RULE_DATASET_DELETE(
  IN P_DEPENDENCY_RULE_DATASET_A DEPENDENCY_RULE_DATASET_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    DEPENDENCY_RULE_DATASET T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID AND
      P.DATASET_ID = T.DATASET_ID);
$BODY$;

COMMENT ON PROCEDURE DEPENDENCY_RULE_DATASET_DELETE
IS 'Delete ocurrences on DEPENDENCY_RULE_DATASET based on array of DEPENDENCY_RULE_DATASET_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_DR_CREATE(
  INOUT P_MAT_DR MAT_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_DR(
    RULE_ID)
  VALUES(
    P_MAT_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_DR_CREATE
IS 'Creates one tuple on MAT_DR from a MAT_DR_TYP object';

CREATE OR REPLACE PROCEDURE MAT_DR_CREATE_MANY(
  INOUT P_MAT_DR_A MAT_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MAT_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_DR_CREATE_MANY
IS 'Creates tuples on MAT_DR from an array of MAT_DR_TYP objects';

CREATE OR REPLACE FUNCTION MAT_DR_FIND_BY_ID(
  IN P_RULE_ID INTEGER
) RETURNS SETOF MAT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MAT_DR
  WHERE 
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MAT_DR_FIND_BY_ID
IS 'Find all ocurrences on MAT_DR based on primary key';

CREATE OR REPLACE FUNCTION MAT_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MAT_DR;
$BODY$;

COMMENT ON FUNCTION MAT_DR_COUNT
IS 'Counts ocurrences on MAT_DR';

CREATE OR REPLACE FUNCTION MAT_DR_FIND_ALL() 
RETURNS SETOF MAT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MAT_DR;
$BODY$;

COMMENT ON FUNCTION MAT_DR_FIND_ALL()
IS 'Find all ocurrences on MAT_DR';

CREATE OR REPLACE PROCEDURE MAT_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MAT_DR;
$BODY$;

COMMENT ON PROCEDURE MAT_DR_DELETE_ALL()
IS 'Delete all ocurrences on MAT_DR';

CREATE OR REPLACE PROCEDURE MAT_DR_UPDATE(
  IN P_MAT_DR_A MAT_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MAT_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MAT_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_DR_UPDATE
IS 'Updates all ocurrences on MAT_DR based on array of MAT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_DR_DELETE(
  IN P_MAT_DR_A MAT_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MAT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MAT_DR_DELETE
IS 'Delete ocurrences on MAT_DR based on array of MAT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_MAT_DR_CREATE(
  INOUT P_MAT_MAT_DR MAT_MAT_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_MAT_DR(
    MAT_ID, RULE_ID)
  VALUES(
    P_MAT_MAT_DR.MAT_ID, P_MAT_MAT_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_MAT_DR_CREATE
IS 'Creates one tuple on MAT_MAT_DR from a MAT_MAT_DR_TYP object';

CREATE OR REPLACE PROCEDURE MAT_MAT_DR_CREATE_MANY(
  INOUT P_MAT_MAT_DR_A MAT_MAT_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MAT_MAT_DR(
    MAT_ID, RULE_ID)
  SELECT
    MAT_ID, RULE_ID
  FROM UNNEST(P_MAT_MAT_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MAT_MAT_DR_CREATE_MANY
IS 'Creates tuples on MAT_MAT_DR from an array of MAT_MAT_DR_TYP objects';

CREATE OR REPLACE FUNCTION MAT_MAT_DR_FIND_BY_ID(
  IN P_MAT_ID INTEGER,
  IN P_RULE_ID INTEGER
) RETURNS SETOF MAT_MAT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, RULE_ID
  FROM MAT_MAT_DR
  WHERE 
    MAT_ID = P_MAT_ID AND
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MAT_MAT_DR_FIND_BY_ID
IS 'Find all ocurrences on MAT_MAT_DR based on primary key';

CREATE OR REPLACE FUNCTION MAT_MAT_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MAT_MAT_DR;
$BODY$;

COMMENT ON FUNCTION MAT_MAT_DR_COUNT
IS 'Counts ocurrences on MAT_MAT_DR';

CREATE OR REPLACE FUNCTION MAT_MAT_DR_FIND_ALL() 
RETURNS SETOF MAT_MAT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MAT_ID, RULE_ID
  FROM MAT_MAT_DR;
$BODY$;

COMMENT ON FUNCTION MAT_MAT_DR_FIND_ALL()
IS 'Find all ocurrences on MAT_MAT_DR';

CREATE OR REPLACE PROCEDURE MAT_MAT_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MAT_MAT_DR;
$BODY$;

COMMENT ON PROCEDURE MAT_MAT_DR_DELETE_ALL()
IS 'Delete all ocurrences on MAT_MAT_DR';

CREATE OR REPLACE PROCEDURE MAT_MAT_DR_UPDATE(
  IN P_MAT_MAT_DR_A MAT_MAT_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MAT_MAT_DR E
  SET 
    MAT_ID=P.MAT_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MAT_MAT_DR_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID AND
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MAT_MAT_DR_UPDATE
IS 'Updates all ocurrences on MAT_MAT_DR based on array of MAT_MAT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MAT_MAT_DR_DELETE(
  IN P_MAT_MAT_DR_A MAT_MAT_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MAT_MAT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_MAT_DR_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID AND
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MAT_MAT_DR_DELETE
IS 'Delete ocurrences on MAT_MAT_DR based on array of MAT_MAT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MO_DR_CREATE(
  INOUT P_MO_DR MO_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_DR(
    RULE_ID)
  VALUES(
    P_MO_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MO_DR_CREATE
IS 'Creates one tuple on MO_DR from a MO_DR_TYP object';

CREATE OR REPLACE PROCEDURE MO_DR_CREATE_MANY(
  INOUT P_MO_DR_A MO_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MO_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MO_DR_CREATE_MANY
IS 'Creates tuples on MO_DR from an array of MO_DR_TYP objects';

CREATE OR REPLACE FUNCTION MO_DR_FIND_BY_ID(
  IN P_RULE_ID INTEGER
) RETURNS SETOF MO_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MO_DR
  WHERE 
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MO_DR_FIND_BY_ID
IS 'Find all ocurrences on MO_DR based on primary key';

CREATE OR REPLACE FUNCTION MO_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MO_DR;
$BODY$;

COMMENT ON FUNCTION MO_DR_COUNT
IS 'Counts ocurrences on MO_DR';

CREATE OR REPLACE FUNCTION MO_DR_FIND_ALL() 
RETURNS SETOF MO_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MO_DR;
$BODY$;

COMMENT ON FUNCTION MO_DR_FIND_ALL()
IS 'Find all ocurrences on MO_DR';

CREATE OR REPLACE PROCEDURE MO_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MO_DR;
$BODY$;

COMMENT ON PROCEDURE MO_DR_DELETE_ALL()
IS 'Delete all ocurrences on MO_DR';

CREATE OR REPLACE PROCEDURE MO_DR_UPDATE(
  IN P_MO_DR_A MO_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MO_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MO_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MO_DR_UPDATE
IS 'Updates all ocurrences on MO_DR based on array of MO_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MO_DR_DELETE(
  IN P_MO_DR_A MO_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MO_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MO_DR_DELETE
IS 'Delete ocurrences on MO_DR based on array of MO_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_MOR_DR_CREATE(
  INOUT P_MO_RELATIONSHIP_MOR_DR MO_RELATIONSHIP_MOR_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_RELATIONSHIP_MOR_DR(
    MOR_ID, RULE_ID)
  VALUES(
    P_MO_RELATIONSHIP_MOR_DR.MOR_ID, P_MO_RELATIONSHIP_MOR_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_MOR_DR_CREATE
IS 'Creates one tuple on MO_RELATIONSHIP_MOR_DR from a MO_RELATIONSHIP_MOR_DR_TYP object';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_MOR_DR_CREATE_MANY(
  INOUT P_MO_RELATIONSHIP_MOR_DR_A MO_RELATIONSHIP_MOR_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MO_RELATIONSHIP_MOR_DR(
    MOR_ID, RULE_ID)
  SELECT
    MOR_ID, RULE_ID
  FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_MOR_DR_CREATE_MANY
IS 'Creates tuples on MO_RELATIONSHIP_MOR_DR from an array of MO_RELATIONSHIP_MOR_DR_TYP objects';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_MOR_DR_FIND_BY_ID(
  IN P_MOR_ID INTEGER,
  IN P_RULE_ID INTEGER
) RETURNS SETOF MO_RELATIONSHIP_MOR_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, RULE_ID
  FROM MO_RELATIONSHIP_MOR_DR
  WHERE 
    MOR_ID = P_MOR_ID AND
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_MOR_DR_FIND_BY_ID
IS 'Find all ocurrences on MO_RELATIONSHIP_MOR_DR based on primary key';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_MOR_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MO_RELATIONSHIP_MOR_DR;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_MOR_DR_COUNT
IS 'Counts ocurrences on MO_RELATIONSHIP_MOR_DR';

CREATE OR REPLACE FUNCTION MO_RELATIONSHIP_MOR_DR_FIND_ALL() 
RETURNS SETOF MO_RELATIONSHIP_MOR_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MOR_ID, RULE_ID
  FROM MO_RELATIONSHIP_MOR_DR;
$BODY$;

COMMENT ON FUNCTION MO_RELATIONSHIP_MOR_DR_FIND_ALL()
IS 'Find all ocurrences on MO_RELATIONSHIP_MOR_DR';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_MOR_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MO_RELATIONSHIP_MOR_DR;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_MOR_DR_DELETE_ALL()
IS 'Delete all ocurrences on MO_RELATIONSHIP_MOR_DR';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_MOR_DR_UPDATE(
  IN P_MO_RELATIONSHIP_MOR_DR_A MO_RELATIONSHIP_MOR_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MO_RELATIONSHIP_MOR_DR E
  SET 
    MOR_ID=P.MOR_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID AND
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_MOR_DR_UPDATE
IS 'Updates all ocurrences on MO_RELATIONSHIP_MOR_DR based on array of MO_RELATIONSHIP_MOR_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MO_RELATIONSHIP_MOR_DR_DELETE(
  IN P_MO_RELATIONSHIP_MOR_DR_A MO_RELATIONSHIP_MOR_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MO_RELATIONSHIP_MOR_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID AND
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MO_RELATIONSHIP_MOR_DR_DELETE
IS 'Delete ocurrences on MO_RELATIONSHIP_MOR_DR based on array of MO_RELATIONSHIP_MOR_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MOR_DR_CREATE(
  INOUT P_MOR_DR MOR_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOR_DR(
    RULE_ID)
  VALUES(
    P_MOR_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MOR_DR_CREATE
IS 'Creates one tuple on MOR_DR from a MOR_DR_TYP object';

CREATE OR REPLACE PROCEDURE MOR_DR_CREATE_MANY(
  INOUT P_MOR_DR_A MOR_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOR_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MOR_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MOR_DR_CREATE_MANY
IS 'Creates tuples on MOR_DR from an array of MOR_DR_TYP objects';

CREATE OR REPLACE FUNCTION MOR_DR_FIND_BY_ID(
  IN P_RULE_ID INTEGER
) RETURNS SETOF MOR_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MOR_DR
  WHERE 
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MOR_DR_FIND_BY_ID
IS 'Find all ocurrences on MOR_DR based on primary key';

CREATE OR REPLACE FUNCTION MOR_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MOR_DR;
$BODY$;

COMMENT ON FUNCTION MOR_DR_COUNT
IS 'Counts ocurrences on MOR_DR';

CREATE OR REPLACE FUNCTION MOR_DR_FIND_ALL() 
RETURNS SETOF MOR_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM MOR_DR;
$BODY$;

COMMENT ON FUNCTION MOR_DR_FIND_ALL()
IS 'Find all ocurrences on MOR_DR';

CREATE OR REPLACE PROCEDURE MOR_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MOR_DR;
$BODY$;

COMMENT ON PROCEDURE MOR_DR_DELETE_ALL()
IS 'Delete all ocurrences on MOR_DR';

CREATE OR REPLACE PROCEDURE MOR_DR_UPDATE(
  IN P_MOR_DR_A MOR_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MOR_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MOR_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MOR_DR_UPDATE
IS 'Updates all ocurrences on MOR_DR based on array of MOR_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MOR_DR_DELETE(
  IN P_MOR_DR_A MOR_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MOR_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOR_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MOR_DR_DELETE
IS 'Delete ocurrences on MOR_DR based on array of MOR_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_MO_DR_CREATE(
  INOUT P_MOVING_OBJECT_MO_DR MOVING_OBJECT_MO_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOVING_OBJECT_MO_DR(
    MO_ID, RULE_ID)
  VALUES(
    P_MOVING_OBJECT_MO_DR.MO_ID, P_MOVING_OBJECT_MO_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_MO_DR_CREATE
IS 'Creates one tuple on MOVING_OBJECT_MO_DR from a MOVING_OBJECT_MO_DR_TYP object';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_MO_DR_CREATE_MANY(
  INOUT P_MOVING_OBJECT_MO_DR_A MOVING_OBJECT_MO_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO MOVING_OBJECT_MO_DR(
    MO_ID, RULE_ID)
  SELECT
    MO_ID, RULE_ID
  FROM UNNEST(P_MOVING_OBJECT_MO_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_MO_DR_CREATE_MANY
IS 'Creates tuples on MOVING_OBJECT_MO_DR from an array of MOVING_OBJECT_MO_DR_TYP objects';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_MO_DR_FIND_BY_ID(
  IN P_MO_ID INTEGER,
  IN P_RULE_ID INTEGER
) RETURNS SETOF MOVING_OBJECT_MO_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, RULE_ID
  FROM MOVING_OBJECT_MO_DR
  WHERE 
    MO_ID = P_MO_ID AND
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_MO_DR_FIND_BY_ID
IS 'Find all ocurrences on MOVING_OBJECT_MO_DR based on primary key';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_MO_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM MOVING_OBJECT_MO_DR;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_MO_DR_COUNT
IS 'Counts ocurrences on MOVING_OBJECT_MO_DR';

CREATE OR REPLACE FUNCTION MOVING_OBJECT_MO_DR_FIND_ALL() 
RETURNS SETOF MOVING_OBJECT_MO_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    MO_ID, RULE_ID
  FROM MOVING_OBJECT_MO_DR;
$BODY$;

COMMENT ON FUNCTION MOVING_OBJECT_MO_DR_FIND_ALL()
IS 'Find all ocurrences on MOVING_OBJECT_MO_DR';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_MO_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM MOVING_OBJECT_MO_DR;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_MO_DR_DELETE_ALL()
IS 'Delete all ocurrences on MOVING_OBJECT_MO_DR';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_MO_DR_UPDATE(
  IN P_MOVING_OBJECT_MO_DR_A MOVING_OBJECT_MO_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE MOVING_OBJECT_MO_DR E
  SET 
    MO_ID=P.MO_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MOVING_OBJECT_MO_DR_A) P
  WHERE 
    E.MO_ID = P.MO_ID AND
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_MO_DR_UPDATE
IS 'Updates all ocurrences on MOVING_OBJECT_MO_DR based on array of MOVING_OBJECT_MO_DR_TYP objects';

CREATE OR REPLACE PROCEDURE MOVING_OBJECT_MO_DR_DELETE(
  IN P_MOVING_OBJECT_MO_DR_A MOVING_OBJECT_MO_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    MOVING_OBJECT_MO_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOVING_OBJECT_MO_DR_A) P
    WHERE 
      P.MO_ID = T.MO_ID AND
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE MOVING_OBJECT_MO_DR_DELETE
IS 'Delete ocurrences on MOVING_OBJECT_MO_DR based on array of MOVING_OBJECT_MO_DR_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_DR_CREATE(
  INOUT P_POINT_DR POINT_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_DR(
    RULE_ID)
  VALUES(
    P_POINT_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_DR_CREATE
IS 'Creates one tuple on POINT_DR from a POINT_DR_TYP object';

CREATE OR REPLACE PROCEDURE POINT_DR_CREATE_MANY(
  INOUT P_POINT_DR_A POINT_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_POINT_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_DR_CREATE_MANY
IS 'Creates tuples on POINT_DR from an array of POINT_DR_TYP objects';

CREATE OR REPLACE FUNCTION POINT_DR_FIND_BY_ID(
  IN P_RULE_ID INTEGER
) RETURNS SETOF POINT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM POINT_DR
  WHERE 
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION POINT_DR_FIND_BY_ID
IS 'Find all ocurrences on POINT_DR based on primary key';

CREATE OR REPLACE FUNCTION POINT_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM POINT_DR;
$BODY$;

COMMENT ON FUNCTION POINT_DR_COUNT
IS 'Counts ocurrences on POINT_DR';

CREATE OR REPLACE FUNCTION POINT_DR_FIND_ALL() 
RETURNS SETOF POINT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    RULE_ID
  FROM POINT_DR;
$BODY$;

COMMENT ON FUNCTION POINT_DR_FIND_ALL()
IS 'Find all ocurrences on POINT_DR';

CREATE OR REPLACE PROCEDURE POINT_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM POINT_DR;
$BODY$;

COMMENT ON PROCEDURE POINT_DR_DELETE_ALL()
IS 'Delete all ocurrences on POINT_DR';

CREATE OR REPLACE PROCEDURE POINT_DR_UPDATE(
  IN P_POINT_DR_A POINT_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE POINT_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_POINT_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_DR_UPDATE
IS 'Updates all ocurrences on POINT_DR based on array of POINT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_DR_DELETE(
  IN P_POINT_DR_A POINT_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    POINT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE POINT_DR_DELETE
IS 'Delete ocurrences on POINT_DR based on array of POINT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_POINT_DR_CREATE(
  INOUT P_POINT_POINT_DR POINT_POINT_DR_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_POINT_DR(
    POINT_ID, RULE_ID)
  VALUES(
    P_POINT_POINT_DR.POINT_ID, P_POINT_POINT_DR.RULE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_POINT_DR_CREATE
IS 'Creates one tuple on POINT_POINT_DR from a POINT_POINT_DR_TYP object';

CREATE OR REPLACE PROCEDURE POINT_POINT_DR_CREATE_MANY(
  INOUT P_POINT_POINT_DR_A POINT_POINT_DR_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO POINT_POINT_DR(
    POINT_ID, RULE_ID)
  SELECT
    POINT_ID, RULE_ID
  FROM UNNEST(P_POINT_POINT_DR_A);
END;
$BODY$;

COMMENT ON PROCEDURE POINT_POINT_DR_CREATE_MANY
IS 'Creates tuples on POINT_POINT_DR from an array of POINT_POINT_DR_TYP objects';

CREATE OR REPLACE FUNCTION POINT_POINT_DR_FIND_BY_ID(
  IN P_POINT_ID INTEGER,
  IN P_RULE_ID INTEGER
) RETURNS SETOF POINT_POINT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, RULE_ID
  FROM POINT_POINT_DR
  WHERE 
    POINT_ID = P_POINT_ID AND
    RULE_ID = P_RULE_ID;
$BODY$;

COMMENT ON FUNCTION POINT_POINT_DR_FIND_BY_ID
IS 'Find all ocurrences on POINT_POINT_DR based on primary key';

CREATE OR REPLACE FUNCTION POINT_POINT_DR_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM POINT_POINT_DR;
$BODY$;

COMMENT ON FUNCTION POINT_POINT_DR_COUNT
IS 'Counts ocurrences on POINT_POINT_DR';

CREATE OR REPLACE FUNCTION POINT_POINT_DR_FIND_ALL() 
RETURNS SETOF POINT_POINT_DR_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    POINT_ID, RULE_ID
  FROM POINT_POINT_DR;
$BODY$;

COMMENT ON FUNCTION POINT_POINT_DR_FIND_ALL()
IS 'Find all ocurrences on POINT_POINT_DR';

CREATE OR REPLACE PROCEDURE POINT_POINT_DR_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM POINT_POINT_DR;
$BODY$;

COMMENT ON PROCEDURE POINT_POINT_DR_DELETE_ALL()
IS 'Delete all ocurrences on POINT_POINT_DR';

CREATE OR REPLACE PROCEDURE POINT_POINT_DR_UPDATE(
  IN P_POINT_POINT_DR_A POINT_POINT_DR_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE POINT_POINT_DR E
  SET 
    POINT_ID=P.POINT_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_POINT_POINT_DR_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.RULE_ID = P.RULE_ID;
$BODY$;

COMMENT ON PROCEDURE POINT_POINT_DR_UPDATE
IS 'Updates all ocurrences on POINT_POINT_DR based on array of POINT_POINT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE POINT_POINT_DR_DELETE(
  IN P_POINT_POINT_DR_A POINT_POINT_DR_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    POINT_POINT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_POINT_DR_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.RULE_ID = T.RULE_ID);
$BODY$;

COMMENT ON PROCEDURE POINT_POINT_DR_DELETE
IS 'Delete ocurrences on POINT_POINT_DR based on array of POINT_POINT_DR_TYP objects';

CREATE OR REPLACE PROCEDURE PREDICATE_CREATE(
  INOUT P_PREDICATE PREDICATE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  P_PREDICATE.PREDICATE_ID := NEXTVAL('PREDICATE_SEQ');
  INSERT INTO PREDICATE(
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED)
  VALUES(
    P_PREDICATE.PREDICATE_ID, P_PREDICATE.DESCRIPTION, P_PREDICATE.PREDICATE_ORDER, P_PREDICATE.PREDICATE_PATH, P_PREDICATE.PARENTHESIS_TYPE, P_PREDICATE.PARENTHESIS_AMOUNT, P_PREDICATE.LOGICAL_OPERATOR, P_PREDICATE.DETERMINANT, P_PREDICATE.DETERMINED);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_CREATE
IS 'Creates one tuple on PREDICATE from a PREDICATE_TYP object';

CREATE OR REPLACE PROCEDURE PREDICATE_CREATE_MANY(
  INOUT P_PREDICATE_A PREDICATE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_PREDICATE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_PREDICATE_A[I].PREDICATE_ID := NEXTVAL('PREDICATE_SEQ');
  END LOOP;
  INSERT INTO PREDICATE(
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED)
  SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM UNNEST(P_PREDICATE_A);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_CREATE_MANY
IS 'Creates tuples on PREDICATE from an array of PREDICATE_TYP objects';

CREATE OR REPLACE FUNCTION PREDICATE_FIND_BY_ID(
  IN P_PREDICATE_ID INTEGER
) RETURNS SETOF PREDICATE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID;
$BODY$;

COMMENT ON FUNCTION PREDICATE_FIND_BY_ID
IS 'Find all ocurrences on PREDICATE based on primary key';

CREATE OR REPLACE FUNCTION PREDICATE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM PREDICATE;
$BODY$;

COMMENT ON FUNCTION PREDICATE_COUNT
IS 'Counts ocurrences on PREDICATE';

CREATE OR REPLACE FUNCTION PREDICATE_FIND_ALL() 
RETURNS SETOF PREDICATE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE;
$BODY$;

COMMENT ON FUNCTION PREDICATE_FIND_ALL()
IS 'Find all ocurrences on PREDICATE';

CREATE OR REPLACE PROCEDURE PREDICATE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM PREDICATE;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_DELETE_ALL()
IS 'Delete all ocurrences on PREDICATE';

CREATE OR REPLACE PROCEDURE PREDICATE_UPDATE(
  IN P_PREDICATE_A PREDICATE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE PREDICATE E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    PREDICATE_ORDER=P.PREDICATE_ORDER, 
    PREDICATE_PATH=P.PREDICATE_PATH, 
    PARENTHESIS_TYPE=P.PARENTHESIS_TYPE, 
    PARENTHESIS_AMOUNT=P.PARENTHESIS_AMOUNT, 
    LOGICAL_OPERATOR=P.LOGICAL_OPERATOR, 
    DETERMINANT=P.DETERMINANT, 
    DETERMINED=P.DETERMINED
  FROM UNNEST(P_PREDICATE_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_UPDATE
IS 'Updates all ocurrences on PREDICATE based on array of PREDICATE_TYP objects';

CREATE OR REPLACE PROCEDURE PREDICATE_DELETE(
  IN P_PREDICATE_A PREDICATE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    PREDICATE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID);
$BODY$;

COMMENT ON PROCEDURE PREDICATE_DELETE
IS 'Delete ocurrences on PREDICATE based on array of PREDICATE_TYP objects';

CREATE OR REPLACE FUNCTION PREDICATE_FIND_BY_NAME(
  IN P_DESCRIPTION VARCHAR(50)
) RETURNS SETOF PREDICATE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE
  WHERE DESCRIPTION = P_DESCRIPTION;
$BODY$;

COMMENT ON FUNCTION PREDICATE_FIND_BY_NAME
IS 'Find all ocurrences on PREDICATE based on name or description';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_CREATE(
  INOUT P_PREDICATE_ASPECT PREDICATE_ASPECT_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO PREDICATE_ASPECT(
    PREDICATE_ID, ASPECT_ID)
  VALUES(
    P_PREDICATE_ASPECT.PREDICATE_ID, P_PREDICATE_ASPECT.ASPECT_ID);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_CREATE
IS 'Creates one tuple on PREDICATE_ASPECT from a PREDICATE_ASPECT_TYP object';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_CREATE_MANY(
  INOUT P_PREDICATE_ASPECT_A PREDICATE_ASPECT_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO PREDICATE_ASPECT(
    PREDICATE_ID, ASPECT_ID)
  SELECT
    PREDICATE_ID, ASPECT_ID
  FROM UNNEST(P_PREDICATE_ASPECT_A);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_CREATE_MANY
IS 'Creates tuples on PREDICATE_ASPECT from an array of PREDICATE_ASPECT_TYP objects';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_FIND_BY_ID(
  IN P_PREDICATE_ID INTEGER,
  IN P_ASPECT_ID INTEGER
) RETURNS SETOF PREDICATE_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, ASPECT_ID
  FROM PREDICATE_ASPECT
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID AND
    ASPECT_ID = P_ASPECT_ID;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_FIND_BY_ID
IS 'Find all ocurrences on PREDICATE_ASPECT based on primary key';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM PREDICATE_ASPECT;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_COUNT
IS 'Counts ocurrences on PREDICATE_ASPECT';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_FIND_ALL() 
RETURNS SETOF PREDICATE_ASPECT_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, ASPECT_ID
  FROM PREDICATE_ASPECT;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_FIND_ALL()
IS 'Find all ocurrences on PREDICATE_ASPECT';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM PREDICATE_ASPECT;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_DELETE_ALL()
IS 'Delete all ocurrences on PREDICATE_ASPECT';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_UPDATE(
  IN P_PREDICATE_ASPECT_A PREDICATE_ASPECT_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE PREDICATE_ASPECT E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_PREDICATE_ASPECT_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID AND
    E.ASPECT_ID = P.ASPECT_ID;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_UPDATE
IS 'Updates all ocurrences on PREDICATE_ASPECT based on array of PREDICATE_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_DELETE(
  IN P_PREDICATE_ASPECT_A PREDICATE_ASPECT_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    PREDICATE_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_ASPECT_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID AND
      P.ASPECT_ID = T.ASPECT_ID);
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_DELETE
IS 'Delete ocurrences on PREDICATE_ASPECT based on array of PREDICATE_ASPECT_TYP objects';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_TYPE_CREATE(
  INOUT P_PREDICATE_ASPECT_TYPE PREDICATE_ASPECT_TYPE_TYP
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO PREDICATE_ASPECT_TYPE(
    PREDICATE_ID, ASPECT_TYPE_ID)
  VALUES(
    P_PREDICATE_ASPECT_TYPE.PREDICATE_ID, P_PREDICATE_ASPECT_TYPE.ASPECT_TYPE_ID);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_TYPE_CREATE
IS 'Creates one tuple on PREDICATE_ASPECT_TYPE from a PREDICATE_ASPECT_TYPE_TYP object';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_TYPE_CREATE_MANY(
  INOUT P_PREDICATE_ASPECT_TYPE_A PREDICATE_ASPECT_TYPE_TYP[]
) LANGUAGE PLPGSQL AS 
$BODY$
BEGIN
  INSERT INTO PREDICATE_ASPECT_TYPE(
    PREDICATE_ID, ASPECT_TYPE_ID)
  SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A);
END;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_TYPE_CREATE_MANY
IS 'Creates tuples on PREDICATE_ASPECT_TYPE from an array of PREDICATE_ASPECT_TYPE_TYP objects';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_TYPE_FIND_BY_ID(
  IN P_PREDICATE_ID INTEGER,
  IN P_ASPECT_TYPE_ID INTEGER
) RETURNS SETOF PREDICATE_ASPECT_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM PREDICATE_ASPECT_TYPE
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID AND
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_TYPE_FIND_BY_ID
IS 'Find all ocurrences on PREDICATE_ASPECT_TYPE based on primary key';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_TYPE_COUNT()
RETURNS INTEGER
LANGUAGE SQL
AS
$BODY$
  SELECT COUNT(*) AS CNT FROM PREDICATE_ASPECT_TYPE;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_TYPE_COUNT
IS 'Counts ocurrences on PREDICATE_ASPECT_TYPE';

CREATE OR REPLACE FUNCTION PREDICATE_ASPECT_TYPE_FIND_ALL() 
RETURNS SETOF PREDICATE_ASPECT_TYPE_TYP
LANGUAGE SQL AS 
$BODY$
  SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM PREDICATE_ASPECT_TYPE;
$BODY$;

COMMENT ON FUNCTION PREDICATE_ASPECT_TYPE_FIND_ALL()
IS 'Find all ocurrences on PREDICATE_ASPECT_TYPE';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_TYPE_DELETE_ALL() 
LANGUAGE SQL AS 
$BODY$
  DELETE    
  FROM PREDICATE_ASPECT_TYPE;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_TYPE_DELETE_ALL()
IS 'Delete all ocurrences on PREDICATE_ASPECT_TYPE';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_TYPE_UPDATE(
  IN P_PREDICATE_ASPECT_TYPE_A PREDICATE_ASPECT_TYPE_TYP[]
)
LANGUAGE SQL AS 
$BODY$
  UPDATE PREDICATE_ASPECT_TYPE E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID
  FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID AND
    E.ASPECT_TYPE_ID = P.ASPECT_TYPE_ID;
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_TYPE_UPDATE
IS 'Updates all ocurrences on PREDICATE_ASPECT_TYPE based on array of PREDICATE_ASPECT_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE PREDICATE_ASPECT_TYPE_DELETE(
  IN P_PREDICATE_ASPECT_TYPE_A PREDICATE_ASPECT_TYPE_TYP[]
) LANGUAGE SQL AS 
$BODY$
  DELETE FROM 
    PREDICATE_ASPECT_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID AND
      P.ASPECT_TYPE_ID = T.ASPECT_TYPE_ID);
$BODY$;

COMMENT ON PROCEDURE PREDICATE_ASPECT_TYPE_DELETE
IS 'Delete ocurrences on PREDICATE_ASPECT_TYPE based on array of PREDICATE_ASPECT_TYPE_TYP objects';

CREATE OR REPLACE PROCEDURE util.create_partitions_by_date(IN p_schemaname text, IN p_tablename text, IN p_startdate date, IN p_enddate date, IN p_columnname text, IN p_interval text, IN p_schemapart text DEFAULT 'partitions'::text)
 LANGUAGE plpgsql
AS $procedure$
declare
  v_d date;
  v_d1 date;
  v_partitionname text;
  v_interval text default '1 ' || p_interval;
 
  c_indexes record;
begin
  if not exists (
    select *
    from information_schema.tables t
    where t.table_name = lower(p_tablename)
    	and t.table_schema = lower(p_schemaname)) 
  then
    raise exception 'table %.% does not exist', p_schemaname, p_tablename;
  end if;
 
  if p_startdate >= p_enddate then
    raise exception 'the start date % must be before the end date %', 
    	p_startdate, p_enddate;
  end if;
 
  v_d := p_startdate;

  while v_d <= p_enddate 
  loop
    v_partitionname := p_tablename || '_' || to_char(v_d, 'yyyy_mm_dd');
   
    if not exists (
      select 1
       from information_schema.tables t
       where t.table_name = lower(v_partitionname)
       	 and t.table_schema = lower(p_schemapart)
    ) then
      v_d1 := v_d + v_interval::interval;
     
      execute format(
      	'create table %s.%s(
				 check ( %s >= date ''%s'' and %s < date ''%s'') 
				) inherits (%s.%s)', 
        p_schemapart, v_partitionname, p_columnname, to_char(v_d, 'yyyy-mm-dd'), 
        p_columnname, to_char(v_d1, 'yyyy-mm-dd'), p_schemaname, p_tablename);

      for c_indexes in
				select 
					replace(
						replace(
							replace(
								pg_get_indexdef(i.indexrelid), 
								p_tablename || ' ', 
								v_partitionname || ' '
							),
							p_tablename || '_pkey', 
							v_partitionname || '_pkey'
						),
						p_schemaname,
						p_schemapart) ind_def 
				from pg_catalog.pg_index i
					inner join pg_catalog.pg_class c on
						c."oid" = i.indrelid 
					inner join pg_catalog.pg_namespace n on
						n."oid" = c.relnamespace 
					where c.relname = p_tablename
						and n.nspname = p_schemaname
	  loop 
	  	execute c_indexes.ind_def;
	  end loop;
		
      raise notice 'partition %.% has been created', 
     		p_schemapart, v_partitionname;
    end if;
   
    v_d := v_d + v_interval::interval;
  end loop;
end;
$procedure$;

COMMENT ON PROCEDURE util.create_partitions_by_date
IS 'Create partitions by date for the relation';
