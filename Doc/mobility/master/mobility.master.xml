<?xml version="1.0" encoding="UTF-8"?><database name="mobility" schema="master" type="PostgreSQL - 14.9 (Ubuntu 14.9-1.pgdg22.04+1)">
   <sequences>
      <sequence increment="1" name="aspect_seq" startValue="1"/>
      <sequence increment="1" name="aspect_type_seq" startValue="1"/>
      <sequence increment="1" name="attribute_seq" startValue="1"/>
      <sequence increment="1" name="data_type_seq" startValue="1"/>
      <sequence increment="1" name="dataset_seq" startValue="1"/>
      <sequence increment="1" name="dependency_rule_seq" startValue="1"/>
      <sequence increment="1" name="disabled_fks_seq" startValue="1"/>
      <sequence increment="1" name="disabled_indexes_seq" startValue="1"/>
      <sequence increment="1" name="mat_dr_seq" startValue="1"/>
      <sequence increment="1" name="mat_mat_dr_seq" startValue="1"/>
      <sequence increment="1" name="mat_seq" startValue="1"/>
      <sequence increment="1" name="mo_dr_seq" startValue="1"/>
      <sequence increment="1" name="mo_relationship_mor_dr_seq" startValue="1"/>
      <sequence increment="1" name="mo_relationship_seq" startValue="1"/>
      <sequence increment="1" name="mo_type_seq" startValue="1"/>
      <sequence increment="1" name="mor_dr_seq" startValue="1"/>
      <sequence increment="1" name="moving_object_mo_dr_seq" startValue="1"/>
      <sequence increment="1" name="moving_object_seq" startValue="1"/>
      <sequence increment="1" name="point_dr_seq" startValue="1"/>
      <sequence increment="1" name="point_point_dr_seq" startValue="1"/>
      <sequence increment="1" name="point_repr_point_seq" startValue="1"/>
      <sequence increment="1" name="point_seq" startValue="1"/>
      <sequence increment="1" name="predicate_aspect_seq" startValue="1"/>
      <sequence increment="1" name="predicate_aspect_type_seq" startValue="1"/>
      <sequence increment="1" name="predicate_seq" startValue="1"/>
   </sequences>
   <tables>
      <table name="aspect" numRows="2300" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="aspect_id" foreignKey="r_49" implied="false" onDeleteCascade="true" schema="master" table="aspect_attribute"/>
            <child column="aspect_id" foreignKey="r_46" implied="false" onDeleteCascade="true" schema="master" table="mat_aspect"/>
            <child column="aspect_id" foreignKey="r_48" implied="false" onDeleteCascade="true" schema="master" table="mo_aspect"/>
            <child column="aspect_id" foreignKey="r_38" implied="false" onDeleteCascade="true" schema="master" table="mor_aspect"/>
            <child column="aspect_id" foreignKey="r_43" implied="false" onDeleteCascade="true" schema="master" table="point_aspect"/>
            <child column="aspect_id" foreignKey="r_52" implied="false" onDeleteCascade="true" schema="master" table="predicate_aspect"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="2" name="x" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="3" name="y" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="t" nullable="true" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="space_time" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="aspect_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_type_id" foreignKey="r_31" implied="false" onDeleteCascade="false" schema="master" table="aspect_type"/>
         </column>
         <primaryKey column="aspect_id" sequenceNumberInPK="1"/>
         <index name="aspect_pkey" unique="true">
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xie1aspect" unique="false">
            <column ascending="true" name="description"/>
         </index>
         <index name="xif1aspect" unique="false">
            <column ascending="true" name="aspect_type_id"/>
         </index>
      </table>
      <table name="aspect_attribute" numRows="6100" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_49" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="attribute_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="attribute_id" foreignKey="r_50" implied="false" onDeleteCascade="true" schema="master" table="attribute"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="value" nullable="false" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="data_type_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="data_type_id" foreignKey="r_52" implied="false" onDeleteCascade="false" schema="master" table="data_type"/>
         </column>
         <primaryKey column="aspect_id" sequenceNumberInPK="1"/>
         <primaryKey column="attribute_id" sequenceNumberInPK="2"/>
         <index name="aspect_attribute_pkey" unique="true">
            <column ascending="true" name="aspect_id"/>
            <column ascending="true" name="attribute_id"/>
         </index>
         <index name="xif1aspect_attribute" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif2aspect_attribute" unique="false">
            <column ascending="true" name="attribute_id"/>
         </index>
         <index name="xif3aspect_attribute" unique="false">
            <column ascending="true" name="data_type_id"/>
         </index>
      </table>
      <table name="aspect_type" numRows="4" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="aspect_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="aspect_type_id" foreignKey="r_31" implied="false" onDeleteCascade="false" schema="master" table="aspect"/>
            <child column="super_type_id" foreignKey="r_51" implied="false" onDeleteCascade="false" schema="master" table="aspect_type"/>
            <child column="aspect_type_id" foreignKey="r_39" implied="false" onDeleteCascade="false" schema="master" table="attribute"/>
            <child column="aspect_type_id" foreignKey="r_55" implied="false" onDeleteCascade="true" schema="master" table="predicate_aspect_type"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="super_type_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_type_id" foreignKey="r_51" implied="false" onDeleteCascade="false" schema="master" table="aspect_type"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <primaryKey column="aspect_type_id" sequenceNumberInPK="1"/>
         <index name="aspect_type_pkey" unique="true">
            <column ascending="true" name="aspect_type_id"/>
         </index>
         <index name="xif1aspect_type" unique="false">
            <column ascending="true" name="super_type_id"/>
         </index>
      </table>
      <table name="attribute" numRows="4" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="attribute_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="attribute_id" foreignKey="r_50" implied="false" onDeleteCascade="true" schema="master" table="aspect_attribute"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="30" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="aspect_type_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_type_id" foreignKey="r_39" implied="false" onDeleteCascade="false" schema="master" table="aspect_type"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="data_type_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="data_type_id" foreignKey="r_53" implied="false" onDeleteCascade="false" schema="master" table="data_type"/>
         </column>
         <primaryKey column="attribute_id" sequenceNumberInPK="1"/>
         <index name="attribute_pkey" unique="true">
            <column ascending="true" name="attribute_id"/>
         </index>
         <index name="xif1atribute" unique="false">
            <column ascending="true" name="aspect_type_id"/>
         </index>
         <index name="xif2atribute" unique="false">
            <column ascending="true" name="data_type_id"/>
         </index>
      </table>
      <table name="data_type" numRows="1" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="data_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="data_type_id" foreignKey="r_52" implied="false" onDeleteCascade="false" schema="master" table="aspect_attribute"/>
            <child column="data_type_id" foreignKey="r_53" implied="false" onDeleteCascade="false" schema="master" table="attribute"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="data_type_name" nullable="true" remarks="" size="30" type="varchar" typeCode="12"/>
         <primaryKey column="data_type_id" sequenceNumberInPK="1"/>
         <index name="data_type_pkey" unique="true">
            <column ascending="true" name="data_type_id"/>
         </index>
      </table>
      <table name="dataset" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="dataset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="dataset_id" foreignKey="r_3" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule_dataset"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="url" nullable="false" remarks="" size="250" type="varchar" typeCode="12"/>
         <primaryKey column="dataset_id" sequenceNumberInPK="1"/>
         <index name="dataset_pkey" unique="true">
            <column ascending="true" name="dataset_id"/>
         </index>
      </table>
      <table name="dependency_rule" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="rule_id" foreignKey="r_2" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule_dataset"/>
            <child column="rule_id" foreignKey="r_36" implied="false" onDeleteCascade="true" schema="master" table="mat_dr"/>
            <child column="rule_id" foreignKey="r_35" implied="false" onDeleteCascade="true" schema="master" table="mo_dr"/>
            <child column="rule_id" foreignKey="r_34" implied="false" onDeleteCascade="true" schema="master" table="mor_dr"/>
            <child column="rule_id" foreignKey="r_37" implied="false" onDeleteCascade="true" schema="master" table="point_dr"/>
            <child column="determinant" foreignKey="r_5" implied="false" onDeleteCascade="false" schema="master" table="predicate"/>
            <child column="determined" foreignKey="r_4" implied="false" onDeleteCascade="false" schema="master" table="predicate"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="start_time" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="end_time" nullable="true" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="confidence" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="dr_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <index name="dependency_rule_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="dependency_rule_dataset" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_2" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="dataset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="dataset_id" foreignKey="r_3" implied="false" onDeleteCascade="true" schema="master" table="dataset"/>
         </column>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <primaryKey column="dataset_id" sequenceNumberInPK="2"/>
         <index name="dependency_rule_dataset_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
            <column ascending="true" name="dataset_id"/>
         </index>
         <index name="xif1dependency_rule_dataset" unique="false">
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif2dependency_rule_dataset" unique="false">
            <column ascending="true" name="dataset_id"/>
         </index>
      </table>
      <table name="mat" numRows="292481" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mat_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="mat_id" foreignKey="r_45" implied="false" onDeleteCascade="true" schema="master" table="mat_aspect"/>
            <child column="mat_id" foreignKey="r_45" implied="false" onDeleteCascade="true" schema="master" table="mat_mat_dr"/>
            <child column="mat_id" foreignKey="r_40" implied="false" onDeleteCascade="false" schema="master" table="point"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="mo_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_id" foreignKey="r_54" implied="false" onDeleteCascade="false" schema="master" table="moving_object"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="raw_trajectory" nullable="false" remarks="" size="2147483647" type="tgeompoint" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="trajectory_geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="mat_date" nullable="true" remarks="" size="13" type="date" typeCode="91"/>
         <primaryKey column="mat_id" sequenceNumberInPK="1"/>
         <index name="mat_pkey" unique="true">
            <column ascending="true" name="mat_id"/>
         </index>
         <index name="xie1mat" unique="false">
            <column ascending="true" name="description"/>
         </index>
         <index name="xif1mat" unique="false">
            <column ascending="true" name="mo_id"/>
         </index>
      </table>
      <table name="mat_aspect" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mat_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mat_id" foreignKey="r_45" implied="false" onDeleteCascade="true" schema="master" table="mat"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_46" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <primaryKey column="mat_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_id" sequenceNumberInPK="2"/>
         <index name="mat_aspect_pkey" unique="true">
            <column ascending="true" name="mat_id"/>
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif1mat_aspect" unique="false">
            <column ascending="true" name="mat_id"/>
         </index>
         <index name="xif2mat_aspect" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
      </table>
      <table name="mat_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="rule_id" foreignKey="r_46" implied="false" onDeleteCascade="true" schema="master" table="mat_mat_dr"/>
            <parent column="rule_id" foreignKey="r_36" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule"/>
         </column>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <index name="mat_dr_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1mat_dr" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="mat_mat_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mat_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mat_id" foreignKey="r_45" implied="false" onDeleteCascade="true" schema="master" table="mat"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_46" implied="false" onDeleteCascade="true" schema="master" table="mat_dr"/>
         </column>
         <primaryKey column="mat_id" sequenceNumberInPK="1"/>
         <primaryKey column="rule_id" sequenceNumberInPK="2"/>
         <index name="mat_mat_dr_pkey" unique="true">
            <column ascending="true" name="mat_id"/>
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1mat_mat_dr" unique="false">
            <column ascending="true" name="mat_id"/>
         </index>
         <index name="xif2mat_mat_dr" unique="false">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="mo_aspect" numRows="2000" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mo_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_id" foreignKey="r_47" implied="false" onDeleteCascade="true" schema="master" table="moving_object"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_48" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="start_time" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="end_time" nullable="true" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="mo_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_id" sequenceNumberInPK="2"/>
         <index name="mo_aspect_pkey" unique="true">
            <column ascending="true" name="mo_id"/>
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif1mo_aspect" unique="false">
            <column ascending="true" name="mo_id"/>
         </index>
         <index name="xif2mo_aspect" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
      </table>
      <table name="mo_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="rule_id" foreignKey="r_43" implied="false" onDeleteCascade="true" schema="master" table="moving_object_mo_dr"/>
            <parent column="rule_id" foreignKey="r_35" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule"/>
         </column>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <index name="mo_dr_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1mo_dr" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="mo_relationship" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="mor_id" foreignKey="r_39" implied="false" onDeleteCascade="true" schema="master" table="mo_relationship_mor_dr"/>
            <child column="mor_id" foreignKey="r_37" implied="false" onDeleteCascade="true" schema="master" table="mor_aspect"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="start_time" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="end_time" nullable="true" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="mo_target" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_id" foreignKey="r_20" implied="false" onDeleteCascade="false" schema="master" table="moving_object"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="mo_source" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_id" foreignKey="r_21" implied="false" onDeleteCascade="false" schema="master" table="moving_object"/>
         </column>
         <primaryKey column="mor_id" sequenceNumberInPK="1"/>
         <index name="mo_relationship_pkey" unique="true">
            <column ascending="true" name="mor_id"/>
         </index>
         <index name="xif1mo_relationship" unique="false">
            <column ascending="true" name="mo_target"/>
         </index>
         <index name="xif2mo_relationship" unique="false">
            <column ascending="true" name="mo_source"/>
         </index>
      </table>
      <table name="mo_relationship_mor_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mor_id" foreignKey="r_39" implied="false" onDeleteCascade="true" schema="master" table="mo_relationship"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_40" implied="false" onDeleteCascade="true" schema="master" table="mor_dr"/>
         </column>
         <primaryKey column="mor_id" sequenceNumberInPK="1"/>
         <primaryKey column="rule_id" sequenceNumberInPK="2"/>
         <index name="mo_relationship_mor_dr_pkey" unique="true">
            <column ascending="true" name="mor_id"/>
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1mo_relationship_mor_dr" unique="false">
            <column ascending="true" name="mor_id"/>
         </index>
         <index name="xif2mo_relationship_mor_dr" unique="false">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="mo_type" numRows="1" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mo_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="mo_type_id" foreignKey="r_19" implied="false" onDeleteCascade="false" schema="master" table="moving_object"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <primaryKey column="mo_type_id" sequenceNumberInPK="1"/>
         <index name="mo_type_pkey" unique="true">
            <column ascending="true" name="mo_type_id"/>
         </index>
      </table>
      <table name="mor_aspect" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mor_id" foreignKey="r_37" implied="false" onDeleteCascade="true" schema="master" table="mo_relationship"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_38" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <primaryKey column="mor_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_id" sequenceNumberInPK="2"/>
         <index name="mor_aspect_pkey" unique="true">
            <column ascending="true" name="mor_id"/>
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif1mo_relationship_aspect" unique="false">
            <column ascending="true" name="mor_id"/>
         </index>
         <index name="xif2mo_relationship_aspect" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
      </table>
      <table name="mor_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="rule_id" foreignKey="r_40" implied="false" onDeleteCascade="true" schema="master" table="mo_relationship_mor_dr"/>
            <parent column="rule_id" foreignKey="r_34" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule"/>
         </column>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <index name="mor_dr_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1mor_dr" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="moving_object" numRows="2000" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mo_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="mo_id" foreignKey="r_54" implied="false" onDeleteCascade="false" schema="master" table="mat"/>
            <child column="mo_id" foreignKey="r_47" implied="false" onDeleteCascade="true" schema="master" table="mo_aspect"/>
            <child column="mo_source" foreignKey="r_21" implied="false" onDeleteCascade="false" schema="master" table="mo_relationship"/>
            <child column="mo_target" foreignKey="r_20" implied="false" onDeleteCascade="false" schema="master" table="mo_relationship"/>
            <child column="mo_id" foreignKey="r_42" implied="false" onDeleteCascade="true" schema="master" table="moving_object_mo_dr"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="mo_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_type_id" foreignKey="r_19" implied="false" onDeleteCascade="false" schema="master" table="mo_type"/>
         </column>
         <primaryKey column="mo_id" sequenceNumberInPK="1"/>
         <index name="moving_object_pkey" unique="true">
            <column ascending="true" name="mo_id"/>
         </index>
         <index name="xie1moving_object" unique="false">
            <column ascending="true" name="description"/>
         </index>
         <index name="xif1moving_object" unique="false">
            <column ascending="true" name="mo_type_id"/>
         </index>
      </table>
      <table name="moving_object_mo_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="mo_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mo_id" foreignKey="r_42" implied="false" onDeleteCascade="true" schema="master" table="moving_object"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_43" implied="false" onDeleteCascade="true" schema="master" table="mo_dr"/>
         </column>
         <primaryKey column="mo_id" sequenceNumberInPK="1"/>
         <primaryKey column="rule_id" sequenceNumberInPK="2"/>
         <index name="moving_object_mo_dr_pkey" unique="true">
            <column ascending="true" name="mo_id"/>
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1moving_object_mo_dr" unique="false">
            <column ascending="true" name="mo_id"/>
         </index>
         <index name="xif2moving_object_mo_dr" unique="false">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="point" numRows="1039258" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="point_id" foreignKey="r_42" implied="false" onDeleteCascade="true" schema="master" table="point_aspect"/>
            <child column="point_id" foreignKey="r_48" implied="false" onDeleteCascade="true" schema="master" table="point_point_dr"/>
            <child column="point_id" foreignKey="r_59" implied="false" onDeleteCascade="true" schema="master" table="point_repr_point"/>
            <child column="repr_point_id" foreignKey="r_57" implied="false" onDeleteCascade="false" schema="master" table="repr_point"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="p_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="mat_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="mat_id" foreignKey="r_40" implied="false" onDeleteCascade="false" schema="master" table="mat"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="t" nullable="true" remarks="" size="13" type="date" typeCode="91"/>
         <primaryKey column="point_id" sequenceNumberInPK="1"/>
         <index name="point_pkey" unique="true">
            <column ascending="true" name="point_id"/>
         </index>
         <index name="xif1point" unique="false">
            <column ascending="true" name="mat_id"/>
         </index>
      </table>
      <table name="point_aspect" numRows="1039258" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="point_id" foreignKey="r_42" implied="false" onDeleteCascade="true" schema="master" table="point"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_43" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <primaryKey column="point_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_id" sequenceNumberInPK="2"/>
         <index name="point_aspect_pkey" unique="true">
            <column ascending="true" name="point_id"/>
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif1point_aspect" unique="false">
            <column ascending="true" name="point_id"/>
         </index>
         <index name="xif2point_aspect" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
      </table>
      <table name="point_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="rule_id" foreignKey="r_49" implied="false" onDeleteCascade="true" schema="master" table="point_point_dr"/>
            <parent column="rule_id" foreignKey="r_37" implied="false" onDeleteCascade="true" schema="master" table="dependency_rule"/>
         </column>
         <primaryKey column="rule_id" sequenceNumberInPK="1"/>
         <index name="point_dr_pkey" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1point_dr" unique="true">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="point_point_dr" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="point_id" foreignKey="r_48" implied="false" onDeleteCascade="true" schema="master" table="point"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rule_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_49" implied="false" onDeleteCascade="true" schema="master" table="point_dr"/>
         </column>
         <primaryKey column="point_id" sequenceNumberInPK="1"/>
         <primaryKey column="rule_id" sequenceNumberInPK="2"/>
         <index name="point_point_dr_pkey" unique="true">
            <column ascending="true" name="point_id"/>
            <column ascending="true" name="rule_id"/>
         </index>
         <index name="xif1point_point_dr" unique="false">
            <column ascending="true" name="point_id"/>
         </index>
         <index name="xif2point_point_dr" unique="false">
            <column ascending="true" name="rule_id"/>
         </index>
      </table>
      <table name="point_repr_point" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="point_id" foreignKey="r_59" implied="false" onDeleteCascade="true" schema="master" table="point"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="repr_point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="repr_point_id" foreignKey="r_60" implied="false" onDeleteCascade="true" schema="master" table="repr_point"/>
         </column>
         <primaryKey column="repr_point_id" sequenceNumberInPK="1"/>
         <primaryKey column="point_id" sequenceNumberInPK="2"/>
         <index name="point_repr_point_pkey" unique="true">
            <column ascending="true" name="repr_point_id"/>
            <column ascending="true" name="point_id"/>
         </index>
         <index name="xif1point_repr_point" unique="false">
            <column ascending="true" name="point_id"/>
         </index>
         <index name="xif2point_repr_point" unique="false">
            <column ascending="true" name="repr_point_id"/>
         </index>
      </table>
      <table name="predicate" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="predicate_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="predicate_id" foreignKey="r_51" implied="false" onDeleteCascade="true" schema="master" table="predicate_aspect"/>
            <child column="predicate_id" foreignKey="r_54" implied="false" onDeleteCascade="true" schema="master" table="predicate_aspect_type"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="predicate_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="predicate_path" nullable="false" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="parenthesis_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="parenthesis_amount" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="logical_operator" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="determined" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_4" implied="false" onDeleteCascade="false" schema="master" table="dependency_rule"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="determinant" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="rule_id" foreignKey="r_5" implied="false" onDeleteCascade="false" schema="master" table="dependency_rule"/>
         </column>
         <primaryKey column="predicate_id" sequenceNumberInPK="1"/>
         <index name="predicate_pkey" unique="true">
            <column ascending="true" name="predicate_id"/>
         </index>
         <index name="xif1predicate" unique="false">
            <column ascending="true" name="determined"/>
         </index>
         <index name="xif2predicate" unique="false">
            <column ascending="true" name="determinant"/>
         </index>
      </table>
      <table name="predicate_aspect" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="predicate_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="predicate_id" foreignKey="r_51" implied="false" onDeleteCascade="true" schema="master" table="predicate"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_id" foreignKey="r_52" implied="false" onDeleteCascade="true" schema="master" table="aspect"/>
         </column>
         <primaryKey column="predicate_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_id" sequenceNumberInPK="2"/>
         <index name="predicate_aspect_pkey" unique="true">
            <column ascending="true" name="predicate_id"/>
            <column ascending="true" name="aspect_id"/>
         </index>
         <index name="xif1predicate_aspect" unique="false">
            <column ascending="true" name="predicate_id"/>
         </index>
         <index name="xif2predicate_aspect" unique="false">
            <column ascending="true" name="aspect_id"/>
         </index>
      </table>
      <table name="predicate_aspect_type" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="predicate_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="predicate_id" foreignKey="r_54" implied="false" onDeleteCascade="true" schema="master" table="predicate"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aspect_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="aspect_type_id" foreignKey="r_55" implied="false" onDeleteCascade="true" schema="master" table="aspect_type"/>
         </column>
         <primaryKey column="predicate_id" sequenceNumberInPK="1"/>
         <primaryKey column="aspect_type_id" sequenceNumberInPK="2"/>
         <index name="predicate_aspect_type_pkey" unique="true">
            <column ascending="true" name="predicate_id"/>
            <column ascending="true" name="aspect_type_id"/>
         </index>
         <index name="xif1predicate_aspect_type" unique="false">
            <column ascending="true" name="predicate_id"/>
         </index>
         <index name="xif2predicate_aspect_type" unique="false">
            <column ascending="true" name="aspect_type_id"/>
         </index>
      </table>
      <table name="repr_point" numRows="0" remarks="" schema="master" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="repr_point_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="repr_point_id" foreignKey="r_60" implied="false" onDeleteCascade="true" schema="master" table="point_repr_point"/>
            <parent column="point_id" foreignKey="r_57" implied="false" onDeleteCascade="false" schema="master" table="point"/>
         </column>
         <primaryKey column="repr_point_id" sequenceNumberInPK="1"/>
         <index name="repr_point_pkey" unique="true">
            <column ascending="true" name="repr_point_id"/>
         </index>
         <index name="xif1repr_point" unique="true">
            <column ascending="true" name="repr_point_id"/>
         </index>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on ASPECT_ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM ASPECT_ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_create(INOUT p_aspect_attribute aspect_attribute_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on ASPECT_ATTRIBUTE from a ASPECT_ATTRIBUTE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO ASPECT_ATTRIBUTE(
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID)
  VALUES(
    P_ASPECT_ATTRIBUTE.ASPECT_ID, P_ASPECT_ATTRIBUTE.ATTRIBUTE_ID, P_ASPECT_ATTRIBUTE.VALUE, P_ASPECT_ATTRIBUTE.DATA_TYPE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect_attribute" type="aspect_attribute_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_create_many(INOUT p_aspect_attribute_a aspect_attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on ASPECT_ATTRIBUTE from an array of ASPECT_ATTRIBUTE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO ASPECT_ATTRIBUTE(
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID)
  SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM UNNEST(P_ASPECT_ATTRIBUTE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect_attribute_a" type="aspect_attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_delete(IN p_aspect_attribute_a aspect_attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT_ATTRIBUTE based on array of ASPECT_ATTRIBUTE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    ASPECT_ATTRIBUTE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_ATTRIBUTE_A) P
    WHERE 
      P.ASPECT_ID = T.ASPECT_ID AND
      P.ATTRIBUTE_ID = T.ATTRIBUTE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_attribute_a" type="aspect_attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on ASPECT_ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM ASPECT_ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_delete_by_id(IN p_aspect_id integer, IN p_attribute_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT_ATTRIBUTE based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ASPECT_ATTRIBUTE
  WHERE 
    ASPECT_ID = P_ASPECT_ID AND
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
            <parameter mode="IN" name="p_attribute_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_find_all()" returnType="SETOF aspect_attribute_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT_ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM ASPECT_ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_find_by_id(p_aspect_id integer, p_attribute_id integer)" returnType="SETOF aspect_attribute_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT_ATTRIBUTE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_ID, ATTRIBUTE_ID, VALUE, DATA_TYPE_ID
  FROM ASPECT_ATTRIBUTE
  WHERE 
    ASPECT_ID = P_ASPECT_ID AND
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
            <parameter mode="IN" name="p_attribute_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_attribute_update(IN p_aspect_attribute_a aspect_attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on ASPECT_ATTRIBUTE based on array of ASPECT_ATTRIBUTE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE ASPECT_ATTRIBUTE E
  SET 
    ASPECT_ID=P.ASPECT_ID, 
    ATTRIBUTE_ID=P.ATTRIBUTE_ID, 
    VALUE=P.VALUE, 
    DATA_TYPE_ID=P.DATA_TYPE_ID
  FROM UNNEST(P_ASPECT_ATTRIBUTE_A) P
  WHERE 
    E.ASPECT_ID = P.ASPECT_ID AND
    E.ATTRIBUTE_ID = P.ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_attribute_a" type="aspect_attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_create(INOUT p_aspect aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on ASPECT from a ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_ASPECT.ASPECT_ID := NEXTVAL('ASPECT_SEQ');
  INSERT INTO ASPECT(
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID)
  VALUES(
    P_ASPECT.ASPECT_ID, P_ASPECT.DESCRIPTION, P_ASPECT.X, P_ASPECT.Y, P_ASPECT.T, P_ASPECT.SPACE_TIME, P_ASPECT.ASPECT_TYPE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect" type="aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_create_many(INOUT p_aspect_a aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on ASPECT from an array of ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ASPECT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ASPECT_A[I].ASPECT_ID := NEXTVAL('ASPECT_SEQ');
  END LOOP;
  INSERT INTO ASPECT(
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID)
  SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM UNNEST(P_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect_a" type="aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_delete(IN p_aspect_a aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT based on array of ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_A) P
    WHERE 
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_a" type="aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_delete_by_id(IN p_aspect_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ASPECT
  WHERE 
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ASPECT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_find_all()" returnType="SETOF aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_find_by_id(p_aspect_id integer)" returnType="SETOF aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT
  WHERE 
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_find_by_name(p_description character varying)" returnType="SETOF aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_ID, DESCRIPTION, X, Y, T, SPACE_TIME, ASPECT_TYPE_ID
  FROM ASPECT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_create(INOUT p_aspect_type aspect_type_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on ASPECT_TYPE from a ASPECT_TYPE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_ASPECT_TYPE.ASPECT_TYPE_ID := NEXTVAL('ASPECT_TYPE_SEQ');
  INSERT INTO ASPECT_TYPE(
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION)
  VALUES(
    P_ASPECT_TYPE.ASPECT_TYPE_ID, P_ASPECT_TYPE.SUPER_TYPE_ID, P_ASPECT_TYPE.DESCRIPTION);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect_type" type="aspect_type_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_create_many(INOUT p_aspect_type_a aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on ASPECT_TYPE from an array of ASPECT_TYPE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ASPECT_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ASPECT_TYPE_A[I].ASPECT_TYPE_ID := NEXTVAL('ASPECT_TYPE_SEQ');
  END LOOP;
  INSERT INTO ASPECT_TYPE(
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION)
  SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM UNNEST(P_ASPECT_TYPE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_aspect_type_a" type="aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_delete(IN p_aspect_type_a aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT_TYPE based on array of ASPECT_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    ASPECT_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ASPECT_TYPE_A) P
    WHERE 
      P.ASPECT_TYPE_ID = T.ASPECT_TYPE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_type_a" type="aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_delete_by_id(IN p_aspect_type_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ASPECT_TYPE
  WHERE 
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ASPECT_TYPE based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ASPECT_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_find_all()" returnType="SETOF aspect_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_find_by_id(p_aspect_type_id integer)" returnType="SETOF aspect_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE
  WHERE 
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_find_by_name(p_description character varying)" returnType="SETOF aspect_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ASPECT_TYPE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ASPECT_TYPE_ID, SUPER_TYPE_ID, DESCRIPTION
  FROM ASPECT_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_type_update(IN p_aspect_type_a aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on ASPECT_TYPE based on array of ASPECT_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE ASPECT_TYPE E
  SET 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID, 
    SUPER_TYPE_ID=P.SUPER_TYPE_ID, 
    DESCRIPTION=P.DESCRIPTION
  FROM UNNEST(P_ASPECT_TYPE_A) P
  WHERE 
    E.ASPECT_TYPE_ID = P.ASPECT_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_type_a" type="aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aspect_update(IN p_aspect_a aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on ASPECT based on array of ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE ASPECT E
  SET 
    ASPECT_ID=P.ASPECT_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    X=P.X, 
    Y=P.Y, 
    T=P.T, 
    SPACE_TIME=P.SPACE_TIME, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID
  FROM UNNEST(P_ASPECT_A) P
  WHERE 
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_aspect_a" type="aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_create(INOUT p_attribute attribute_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on ATTRIBUTE from a ATTRIBUTE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_ATTRIBUTE.ATTRIBUTE_ID := NEXTVAL('ATTRIBUTE_SEQ');
  INSERT INTO ATTRIBUTE(
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID)
  VALUES(
    P_ATTRIBUTE.ATTRIBUTE_ID, P_ATTRIBUTE.NAME, P_ATTRIBUTE.ASPECT_TYPE_ID, P_ATTRIBUTE.DATA_TYPE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_attribute" type="attribute_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_create_many(INOUT p_attribute_a attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on ATTRIBUTE from an array of ATTRIBUTE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_ATTRIBUTE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_ATTRIBUTE_A[I].ATTRIBUTE_ID := NEXTVAL('ATTRIBUTE_SEQ');
  END LOOP;
  INSERT INTO ATTRIBUTE(
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID)
  SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM UNNEST(P_ATTRIBUTE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_attribute_a" type="attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_delete(IN p_attribute_a attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ATTRIBUTE based on array of ATTRIBUTE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    ATTRIBUTE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_ATTRIBUTE_A) P
    WHERE 
      P.ATTRIBUTE_ID = T.ATTRIBUTE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_attribute_a" type="attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_delete_by_id(IN p_attribute_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ATTRIBUTE based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ATTRIBUTE
  WHERE 
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_attribute_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_delete_by_name(IN p_name character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on ATTRIBUTE based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM ATTRIBUTE
  WHERE NAME = P_NAME;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_find_all()" returnType="SETOF attribute_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ATTRIBUTE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_find_by_id(p_attribute_id integer)" returnType="SETOF attribute_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ATTRIBUTE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE
  WHERE 
    ATTRIBUTE_ID = P_ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_attribute_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_find_by_name(p_name character varying)" returnType="SETOF attribute_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on ATTRIBUTE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    ATTRIBUTE_ID, NAME, ASPECT_TYPE_ID, DATA_TYPE_ID
  FROM ATTRIBUTE
  WHERE NAME = P_NAME;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="attribute_update(IN p_attribute_a attribute_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on ATTRIBUTE based on array of ATTRIBUTE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE ATTRIBUTE E
  SET 
    ATTRIBUTE_ID=P.ATTRIBUTE_ID, 
    NAME=P.NAME, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID, 
    DATA_TYPE_ID=P.DATA_TYPE_ID
  FROM UNNEST(P_ATTRIBUTE_A) P
  WHERE 
    E.ATTRIBUTE_ID = P.ATTRIBUTE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_attribute_a" type="attribute_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on DATA_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM DATA_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_create(INOUT p_data_type data_type_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on DATA_TYPE from a DATA_TYPE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_DATA_TYPE.DATA_TYPE_ID := NEXTVAL('DATA_TYPE_SEQ');
  INSERT INTO DATA_TYPE(
    DATA_TYPE_ID, DATA_TYPE_NAME)
  VALUES(
    P_DATA_TYPE.DATA_TYPE_ID, P_DATA_TYPE.DATA_TYPE_NAME);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_data_type" type="data_type_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_create_many(INOUT p_data_type_a data_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on DATA_TYPE from an array of DATA_TYPE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DATA_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DATA_TYPE_A[I].DATA_TYPE_ID := NEXTVAL('DATA_TYPE_SEQ');
  END LOOP;
  INSERT INTO DATA_TYPE(
    DATA_TYPE_ID, DATA_TYPE_NAME)
  SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM UNNEST(P_DATA_TYPE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_data_type_a" type="data_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_delete(IN p_data_type_a data_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DATA_TYPE based on array of DATA_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    DATA_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DATA_TYPE_A) P
    WHERE 
      P.DATA_TYPE_ID = T.DATA_TYPE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_a" type="data_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on DATA_TYPE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM DATA_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_delete_by_id(IN p_data_type_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DATA_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM DATA_TYPE
  WHERE 
    DATA_TYPE_ID = P_DATA_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_delete_by_name(IN p_data_type_name character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DATA_TYPE based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM DATA_TYPE
  WHERE DATA_TYPE_NAME = P_DATA_TYPE_NAME;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_find_all()" returnType="SETOF data_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATA_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_find_by_id(p_data_type_id integer)" returnType="SETOF data_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATA_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE
  WHERE 
    DATA_TYPE_ID = P_DATA_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_find_by_name(p_data_type_name character varying)" returnType="SETOF data_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATA_TYPE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATA_TYPE_ID, DATA_TYPE_NAME
  FROM DATA_TYPE
  WHERE DATA_TYPE_NAME = P_DATA_TYPE_NAME;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="data_type_update(IN p_data_type_a data_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on DATA_TYPE based on array of DATA_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE DATA_TYPE E
  SET 
    DATA_TYPE_ID=P.DATA_TYPE_ID, 
    DATA_TYPE_NAME=P.DATA_TYPE_NAME
  FROM UNNEST(P_DATA_TYPE_A) P
  WHERE 
    E.DATA_TYPE_ID = P.DATA_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_data_type_a" type="data_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on DATASET]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_create(INOUT p_dataset dataset_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on DATASET from a DATASET_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_DATASET.DATASET_ID := NEXTVAL('DATASET_SEQ');
  INSERT INTO DATASET(
    DATASET_ID, DESCRIPTION, URL)
  VALUES(
    P_DATASET.DATASET_ID, P_DATASET.DESCRIPTION, P_DATASET.URL);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dataset" type="dataset_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_create_many(INOUT p_dataset_a dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on DATASET from an array of DATASET_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DATASET_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DATASET_A[I].DATASET_ID := NEXTVAL('DATASET_SEQ');
  END LOOP;
  INSERT INTO DATASET(
    DATASET_ID, DESCRIPTION, URL)
  SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM UNNEST(P_DATASET_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dataset_a" type="dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_delete(IN p_dataset_a dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DATASET based on array of DATASET_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    DATASET T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DATASET_A) P
    WHERE 
      P.DATASET_ID = T.DATASET_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dataset_a" type="dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on DATASET]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_find_all()" returnType="SETOF dataset_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATASET]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_find_by_id(p_dataset_id integer)" returnType="SETOF dataset_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATASET based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET
  WHERE 
    DATASET_ID = P_DATASET_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dataset_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_find_by_name(p_description character varying)" returnType="SETOF dataset_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DATASET based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    DATASET_ID, DESCRIPTION, URL
  FROM DATASET
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dataset_update(IN p_dataset_a dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on DATASET based on array of DATASET_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE DATASET E
  SET 
    DATASET_ID=P.DATASET_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    URL=P.URL
  FROM UNNEST(P_DATASET_A) P
  WHERE 
    E.DATASET_ID = P.DATASET_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dataset_a" type="dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on DEPENDENCY_RULE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM DEPENDENCY_RULE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_create(INOUT p_dependency_rule dependency_rule_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on DEPENDENCY_RULE from a DEPENDENCY_RULE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_DEPENDENCY_RULE.RULE_ID := NEXTVAL('DEPENDENCY_RULE_SEQ');
  INSERT INTO DEPENDENCY_RULE(
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE)
  VALUES(
    P_DEPENDENCY_RULE.RULE_ID, P_DEPENDENCY_RULE.DESCRIPTION, P_DEPENDENCY_RULE.START_TIME, P_DEPENDENCY_RULE.END_TIME, P_DEPENDENCY_RULE.CONFIDENCE, P_DEPENDENCY_RULE.DR_TYPE);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dependency_rule" type="dependency_rule_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_create_many(INOUT p_dependency_rule_a dependency_rule_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on DEPENDENCY_RULE from an array of DEPENDENCY_RULE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_DEPENDENCY_RULE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_DEPENDENCY_RULE_A[I].RULE_ID := NEXTVAL('DEPENDENCY_RULE_SEQ');
  END LOOP;
  INSERT INTO DEPENDENCY_RULE(
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE)
  SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM UNNEST(P_DEPENDENCY_RULE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dependency_rule_a" type="dependency_rule_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on DEPENDENCY_RULE_DATASET]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM DEPENDENCY_RULE_DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_create(INOUT p_dependency_rule_dataset dependency_rule_dataset_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on DEPENDENCY_RULE_DATASET from a DEPENDENCY_RULE_DATASET_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO DEPENDENCY_RULE_DATASET(
    RULE_ID, DATASET_ID)
  VALUES(
    P_DEPENDENCY_RULE_DATASET.RULE_ID, P_DEPENDENCY_RULE_DATASET.DATASET_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dependency_rule_dataset" type="dependency_rule_dataset_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_create_many(INOUT p_dependency_rule_dataset_a dependency_rule_dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on DEPENDENCY_RULE_DATASET from an array of DEPENDENCY_RULE_DATASET_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO DEPENDENCY_RULE_DATASET(
    RULE_ID, DATASET_ID)
  SELECT
    RULE_ID, DATASET_ID
  FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_dependency_rule_dataset_a" type="dependency_rule_dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_delete(IN p_dependency_rule_dataset_a dependency_rule_dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DEPENDENCY_RULE_DATASET based on array of DEPENDENCY_RULE_DATASET_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    DEPENDENCY_RULE_DATASET T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID AND
      P.DATASET_ID = T.DATASET_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dependency_rule_dataset_a" type="dependency_rule_dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on DEPENDENCY_RULE_DATASET]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM DEPENDENCY_RULE_DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_find_all()" returnType="SETOF dependency_rule_dataset_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DEPENDENCY_RULE_DATASET]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID, DATASET_ID
  FROM DEPENDENCY_RULE_DATASET;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_find_by_id(p_rule_id integer, p_dataset_id integer)" returnType="SETOF dependency_rule_dataset_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DEPENDENCY_RULE_DATASET based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID, DATASET_ID
  FROM DEPENDENCY_RULE_DATASET
  WHERE 
    RULE_ID = P_RULE_ID AND
    DATASET_ID = P_DATASET_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
            <parameter mode="IN" name="p_dataset_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_dataset_update(IN p_dependency_rule_dataset_a dependency_rule_dataset_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on DEPENDENCY_RULE_DATASET based on array of DEPENDENCY_RULE_DATASET_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE DEPENDENCY_RULE_DATASET E
  SET 
    RULE_ID=P.RULE_ID, 
    DATASET_ID=P.DATASET_ID
  FROM UNNEST(P_DEPENDENCY_RULE_DATASET_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID AND
    E.DATASET_ID = P.DATASET_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dependency_rule_dataset_a" type="dependency_rule_dataset_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_delete(IN p_dependency_rule_a dependency_rule_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on DEPENDENCY_RULE based on array of DEPENDENCY_RULE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    DEPENDENCY_RULE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_DEPENDENCY_RULE_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dependency_rule_a" type="dependency_rule_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on DEPENDENCY_RULE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM DEPENDENCY_RULE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_find_all()" returnType="SETOF dependency_rule_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DEPENDENCY_RULE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_find_by_id(p_rule_id integer)" returnType="SETOF dependency_rule_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DEPENDENCY_RULE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE
  WHERE 
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_find_by_name(p_description character varying)" returnType="SETOF dependency_rule_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on DEPENDENCY_RULE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID, DESCRIPTION, START_TIME, END_TIME, CONFIDENCE, DR_TYPE
  FROM DEPENDENCY_RULE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dependency_rule_update(IN p_dependency_rule_a dependency_rule_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on DEPENDENCY_RULE based on array of DEPENDENCY_RULE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE DEPENDENCY_RULE E
  SET 
    RULE_ID=P.RULE_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME, 
    CONFIDENCE=P.CONFIDENCE, 
    DR_TYPE=P.DR_TYPE
  FROM UNNEST(P_DEPENDENCY_RULE_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_dependency_rule_a" type="dependency_rule_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MAT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MAT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_create(INOUT p_mat_aspect mat_aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MAT_ASPECT from a MAT_ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_ASPECT(
    MAT_ID, ASPECT_ID)
  VALUES(
    P_MAT_ASPECT.MAT_ID, P_MAT_ASPECT.ASPECT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_aspect" type="mat_aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_create_many(INOUT p_mat_aspect_a mat_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MAT_ASPECT from an array of MAT_ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_ASPECT(
    MAT_ID, ASPECT_ID)
  SELECT
    MAT_ID, ASPECT_ID
  FROM UNNEST(P_MAT_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_aspect_a" type="mat_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_delete(IN p_mat_aspect_a mat_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT_ASPECT based on array of MAT_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MAT_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_ASPECT_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID AND
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_aspect_a" type="mat_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MAT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MAT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_delete_by_id(IN p_mat_id integer, IN p_aspect_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MAT_ASPECT
  WHERE 
    MAT_ID = P_MAT_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_find_all()" returnType="SETOF mat_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, ASPECT_ID
  FROM MAT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_find_by_id(p_mat_id integer, p_aspect_id integer)" returnType="SETOF mat_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, ASPECT_ID
  FROM MAT_ASPECT
  WHERE 
    MAT_ID = P_MAT_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_aspect_update(IN p_mat_aspect_a mat_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MAT_ASPECT based on array of MAT_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MAT_ASPECT E
  SET 
    MAT_ID=P.MAT_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_MAT_ASPECT_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID AND
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_aspect_a" type="mat_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MAT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MAT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_create(INOUT p_mat mat_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MAT from a MAT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_MAT.MAT_ID := NEXTVAL('MAT_SEQ');
  INSERT INTO MAT(
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE)
  VALUES(
    P_MAT.MAT_ID, P_MAT.DESCRIPTION, P_MAT.MO_ID, P_MAT.RAW_TRAJECTORY, P_MAT.TRAJECTORY_GEOM, P_MAT.MAT_DATE);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat" type="mat_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_create_many(INOUT p_mat_a mat_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MAT from an array of MAT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MAT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MAT_A[I].MAT_ID := NEXTVAL('MAT_SEQ');
  END LOOP;
  INSERT INTO MAT(
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE)
  SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM UNNEST(P_MAT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_a" type="mat_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_delete(IN p_mat_a mat_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT based on array of MAT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MAT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_a" type="mat_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MAT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MAT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_delete_by_id(IN p_mat_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MAT
  WHERE 
    MAT_ID = P_MAT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MAT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MAT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_create(INOUT p_mat_dr mat_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MAT_DR from a MAT_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_DR(
    RULE_ID)
  VALUES(
    P_MAT_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_dr" type="mat_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_create_many(INOUT p_mat_dr_a mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MAT_DR from an array of MAT_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MAT_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_dr_a" type="mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_delete(IN p_mat_dr_a mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT_DR based on array of MAT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MAT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_dr_a" type="mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MAT_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_find_all()" returnType="SETOF mat_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_find_by_id(p_rule_id integer)" returnType="SETOF mat_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MAT_DR
  WHERE 
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_dr_update(IN p_mat_dr_a mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MAT_DR based on array of MAT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MAT_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MAT_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_dr_a" type="mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_find_all()" returnType="SETOF mat_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_find_by_id(p_mat_id integer)" returnType="SETOF mat_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT
  WHERE 
    MAT_ID = P_MAT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_find_by_name(p_description character varying)" returnType="SETOF mat_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, DESCRIPTION, MO_ID, RAW_TRAJECTORY, TRAJECTORY_GEOM, MAT_DATE
  FROM MAT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MAT_MAT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MAT_MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_create(INOUT p_mat_mat_dr mat_mat_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MAT_MAT_DR from a MAT_MAT_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_MAT_DR(
    MAT_ID, RULE_ID)
  VALUES(
    P_MAT_MAT_DR.MAT_ID, P_MAT_MAT_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_mat_dr" type="mat_mat_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_create_many(INOUT p_mat_mat_dr_a mat_mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MAT_MAT_DR from an array of MAT_MAT_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MAT_MAT_DR(
    MAT_ID, RULE_ID)
  SELECT
    MAT_ID, RULE_ID
  FROM UNNEST(P_MAT_MAT_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mat_mat_dr_a" type="mat_mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_delete(IN p_mat_mat_dr_a mat_mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MAT_MAT_DR based on array of MAT_MAT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MAT_MAT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MAT_MAT_DR_A) P
    WHERE 
      P.MAT_ID = T.MAT_ID AND
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_mat_dr_a" type="mat_mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MAT_MAT_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MAT_MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_find_all()" returnType="SETOF mat_mat_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_MAT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, RULE_ID
  FROM MAT_MAT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_find_by_id(p_mat_id integer, p_rule_id integer)" returnType="SETOF mat_mat_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MAT_MAT_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MAT_ID, RULE_ID
  FROM MAT_MAT_DR
  WHERE 
    MAT_ID = P_MAT_ID AND
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_id" type="integer"/>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_mat_dr_update(IN p_mat_mat_dr_a mat_mat_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MAT_MAT_DR based on array of MAT_MAT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MAT_MAT_DR E
  SET 
    MAT_ID=P.MAT_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MAT_MAT_DR_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID AND
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_mat_dr_a" type="mat_mat_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mat_update(IN p_mat_a mat_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MAT based on array of MAT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MAT E
  SET 
    MAT_ID=P.MAT_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    MO_ID=P.MO_ID, 
    RAW_TRAJECTORY=P.RAW_TRAJECTORY, 
    TRAJECTORY_GEOM=P.TRAJECTORY_GEOM, 
    MAT_DATE=P.MAT_DATE
  FROM UNNEST(P_MAT_A) P
  WHERE 
    E.MAT_ID = P.MAT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mat_a" type="mat_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MO_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MO_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_create(INOUT p_mo_aspect mo_aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MO_ASPECT from a MO_ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_ASPECT(
    MO_ID, ASPECT_ID, START_TIME, END_TIME)
  VALUES(
    P_MO_ASPECT.MO_ID, P_MO_ASPECT.ASPECT_ID, P_MO_ASPECT.START_TIME, P_MO_ASPECT.END_TIME);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_aspect" type="mo_aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_create_many(INOUT p_mo_aspect_a mo_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MO_ASPECT from an array of MO_ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_ASPECT(
    MO_ID, ASPECT_ID, START_TIME, END_TIME)
  SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM UNNEST(P_MO_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_aspect_a" type="mo_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_delete(IN p_mo_aspect_a mo_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_ASPECT based on array of MO_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MO_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_ASPECT_A) P
    WHERE 
      P.MO_ID = T.MO_ID AND
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_aspect_a" type="mo_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MO_ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MO_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_delete_by_id(IN p_mo_id integer, IN p_aspect_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MO_ASPECT
  WHERE 
    MO_ID = P_MO_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_find_all()" returnType="SETOF mo_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM MO_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_find_by_id(p_mo_id integer, p_aspect_id integer)" returnType="SETOF mo_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, ASPECT_ID, START_TIME, END_TIME
  FROM MO_ASPECT
  WHERE 
    MO_ID = P_MO_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_aspect_update(IN p_mo_aspect_a mo_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MO_ASPECT based on array of MO_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MO_ASPECT E
  SET 
    MO_ID=P.MO_ID, 
    ASPECT_ID=P.ASPECT_ID, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME
  FROM UNNEST(P_MO_ASPECT_A) P
  WHERE 
    E.MO_ID = P.MO_ID AND
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_aspect_a" type="mo_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MO_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_create(INOUT p_mo_dr mo_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MO_DR from a MO_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_DR(
    RULE_ID)
  VALUES(
    P_MO_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_dr" type="mo_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_create_many(INOUT p_mo_dr_a mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MO_DR from an array of MO_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MO_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_dr_a" type="mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_delete(IN p_mo_dr_a mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_DR based on array of MO_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MO_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_dr_a" type="mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MO_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_find_all()" returnType="SETOF mo_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_find_by_id(p_rule_id integer)" returnType="SETOF mo_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MO_DR
  WHERE 
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_dr_update(IN p_mo_dr_a mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MO_DR based on array of MO_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MO_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MO_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_dr_a" type="mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MO_RELATIONSHIP]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MO_RELATIONSHIP;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_create(INOUT p_mo_relationship mo_relationship_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MO_RELATIONSHIP from a MO_RELATIONSHIP_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_MO_RELATIONSHIP.MOR_ID := NEXTVAL('MO_RELATIONSHIP_SEQ');
  INSERT INTO MO_RELATIONSHIP(
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE)
  VALUES(
    P_MO_RELATIONSHIP.MOR_ID, P_MO_RELATIONSHIP.DESCRIPTION, P_MO_RELATIONSHIP.START_TIME, P_MO_RELATIONSHIP.END_TIME, P_MO_RELATIONSHIP.MO_TARGET, P_MO_RELATIONSHIP.MO_SOURCE);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_relationship" type="mo_relationship_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_create_many(INOUT p_mo_relationship_a mo_relationship_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MO_RELATIONSHIP from an array of MO_RELATIONSHIP_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MO_RELATIONSHIP_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MO_RELATIONSHIP_A[I].MOR_ID := NEXTVAL('MO_RELATIONSHIP_SEQ');
  END LOOP;
  INSERT INTO MO_RELATIONSHIP(
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE)
  SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM UNNEST(P_MO_RELATIONSHIP_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_relationship_a" type="mo_relationship_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_delete(IN p_mo_relationship_a mo_relationship_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_RELATIONSHIP based on array of MO_RELATIONSHIP_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MO_RELATIONSHIP T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_RELATIONSHIP_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_relationship_a" type="mo_relationship_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MO_RELATIONSHIP]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MO_RELATIONSHIP;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_delete_by_id(IN p_mor_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_RELATIONSHIP based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MO_RELATIONSHIP
  WHERE 
    MOR_ID = P_MOR_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_RELATIONSHIP based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MO_RELATIONSHIP
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_find_all()" returnType="SETOF mo_relationship_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_RELATIONSHIP]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_find_by_id(p_mor_id integer)" returnType="SETOF mo_relationship_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_RELATIONSHIP based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP
  WHERE 
    MOR_ID = P_MOR_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_find_by_name(p_description character varying)" returnType="SETOF mo_relationship_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_RELATIONSHIP based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, DESCRIPTION, START_TIME, END_TIME, MO_TARGET, MO_SOURCE
  FROM MO_RELATIONSHIP
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MO_RELATIONSHIP_MOR_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MO_RELATIONSHIP_MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_create(INOUT p_mo_relationship_mor_dr mo_relationship_mor_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MO_RELATIONSHIP_MOR_DR from a MO_RELATIONSHIP_MOR_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_RELATIONSHIP_MOR_DR(
    MOR_ID, RULE_ID)
  VALUES(
    P_MO_RELATIONSHIP_MOR_DR.MOR_ID, P_MO_RELATIONSHIP_MOR_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_relationship_mor_dr" type="mo_relationship_mor_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_create_many(INOUT p_mo_relationship_mor_dr_a mo_relationship_mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MO_RELATIONSHIP_MOR_DR from an array of MO_RELATIONSHIP_MOR_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MO_RELATIONSHIP_MOR_DR(
    MOR_ID, RULE_ID)
  SELECT
    MOR_ID, RULE_ID
  FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_relationship_mor_dr_a" type="mo_relationship_mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_delete(IN p_mo_relationship_mor_dr_a mo_relationship_mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_RELATIONSHIP_MOR_DR based on array of MO_RELATIONSHIP_MOR_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MO_RELATIONSHIP_MOR_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID AND
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_relationship_mor_dr_a" type="mo_relationship_mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MO_RELATIONSHIP_MOR_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MO_RELATIONSHIP_MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_find_all()" returnType="SETOF mo_relationship_mor_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_RELATIONSHIP_MOR_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, RULE_ID
  FROM MO_RELATIONSHIP_MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_find_by_id(p_mor_id integer, p_rule_id integer)" returnType="SETOF mo_relationship_mor_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_RELATIONSHIP_MOR_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, RULE_ID
  FROM MO_RELATIONSHIP_MOR_DR
  WHERE 
    MOR_ID = P_MOR_ID AND
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_id" type="integer"/>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_mor_dr_update(IN p_mo_relationship_mor_dr_a mo_relationship_mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MO_RELATIONSHIP_MOR_DR based on array of MO_RELATIONSHIP_MOR_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MO_RELATIONSHIP_MOR_DR E
  SET 
    MOR_ID=P.MOR_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MO_RELATIONSHIP_MOR_DR_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID AND
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_relationship_mor_dr_a" type="mo_relationship_mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_relationship_update(IN p_mo_relationship_a mo_relationship_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MO_RELATIONSHIP based on array of MO_RELATIONSHIP_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MO_RELATIONSHIP E
  SET 
    MOR_ID=P.MOR_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    START_TIME=P.START_TIME, 
    END_TIME=P.END_TIME, 
    MO_TARGET=P.MO_TARGET, 
    MO_SOURCE=P.MO_SOURCE
  FROM UNNEST(P_MO_RELATIONSHIP_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_relationship_a" type="mo_relationship_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MO_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MO_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_create(INOUT p_mo_type mo_type_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MO_TYPE from a MO_TYPE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_MO_TYPE.MO_TYPE_ID := NEXTVAL('MO_TYPE_SEQ');
  INSERT INTO MO_TYPE(
    MO_TYPE_ID, DESCRIPTION)
  VALUES(
    P_MO_TYPE.MO_TYPE_ID, P_MO_TYPE.DESCRIPTION);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_type" type="mo_type_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_create_many(INOUT p_mo_type_a mo_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MO_TYPE from an array of MO_TYPE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MO_TYPE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MO_TYPE_A[I].MO_TYPE_ID := NEXTVAL('MO_TYPE_SEQ');
  END LOOP;
  INSERT INTO MO_TYPE(
    MO_TYPE_ID, DESCRIPTION)
  SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM UNNEST(P_MO_TYPE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mo_type_a" type="mo_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_delete(IN p_mo_type_a mo_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_TYPE based on array of MO_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MO_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MO_TYPE_A) P
    WHERE 
      P.MO_TYPE_ID = T.MO_TYPE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_type_a" type="mo_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MO_TYPE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MO_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_delete_by_id(IN p_mo_type_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MO_TYPE
  WHERE 
    MO_TYPE_ID = P_MO_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MO_TYPE based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MO_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_find_all()" returnType="SETOF mo_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_find_by_id(p_mo_type_id integer)" returnType="SETOF mo_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE
  WHERE 
    MO_TYPE_ID = P_MO_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_find_by_name(p_description character varying)" returnType="SETOF mo_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MO_TYPE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_TYPE_ID, DESCRIPTION
  FROM MO_TYPE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mo_type_update(IN p_mo_type_a mo_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MO_TYPE based on array of MO_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MO_TYPE E
  SET 
    MO_TYPE_ID=P.MO_TYPE_ID, 
    DESCRIPTION=P.DESCRIPTION
  FROM UNNEST(P_MO_TYPE_A) P
  WHERE 
    E.MO_TYPE_ID = P.MO_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_type_a" type="mo_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MOR_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MOR_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_create(INOUT p_mor_aspect mor_aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MOR_ASPECT from a MOR_ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOR_ASPECT(
    MOR_ID, ASPECT_ID)
  VALUES(
    P_MOR_ASPECT.MOR_ID, P_MOR_ASPECT.ASPECT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mor_aspect" type="mor_aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_create_many(INOUT p_mor_aspect_a mor_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MOR_ASPECT from an array of MOR_ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOR_ASPECT(
    MOR_ID, ASPECT_ID)
  SELECT
    MOR_ID, ASPECT_ID
  FROM UNNEST(P_MOR_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mor_aspect_a" type="mor_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_delete(IN p_mor_aspect_a mor_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOR_ASPECT based on array of MOR_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MOR_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOR_ASPECT_A) P
    WHERE 
      P.MOR_ID = T.MOR_ID AND
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_aspect_a" type="mor_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MOR_ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MOR_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_delete_by_id(IN p_mor_id integer, IN p_aspect_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOR_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MOR_ASPECT
  WHERE 
    MOR_ID = P_MOR_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_find_all()" returnType="SETOF mor_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOR_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, ASPECT_ID
  FROM MOR_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_find_by_id(p_mor_id integer, p_aspect_id integer)" returnType="SETOF mor_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOR_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MOR_ID, ASPECT_ID
  FROM MOR_ASPECT
  WHERE 
    MOR_ID = P_MOR_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_aspect_update(IN p_mor_aspect_a mor_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MOR_ASPECT based on array of MOR_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MOR_ASPECT E
  SET 
    MOR_ID=P.MOR_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_MOR_ASPECT_A) P
  WHERE 
    E.MOR_ID = P.MOR_ID AND
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_aspect_a" type="mor_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MOR_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_create(INOUT p_mor_dr mor_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MOR_DR from a MOR_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOR_DR(
    RULE_ID)
  VALUES(
    P_MOR_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mor_dr" type="mor_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_create_many(INOUT p_mor_dr_a mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MOR_DR from an array of MOR_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOR_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_MOR_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_mor_dr_a" type="mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_delete(IN p_mor_dr_a mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOR_DR based on array of MOR_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MOR_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOR_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_dr_a" type="mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MOR_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_find_all()" returnType="SETOF mor_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOR_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MOR_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_find_by_id(p_rule_id integer)" returnType="SETOF mor_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOR_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM MOR_DR
  WHERE 
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mor_dr_update(IN p_mor_dr_a mor_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MOR_DR based on array of MOR_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MOR_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MOR_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mor_dr_a" type="mor_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MOVING_OBJECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MOVING_OBJECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_create(INOUT p_moving_object moving_object_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MOVING_OBJECT from a MOVING_OBJECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_MOVING_OBJECT.MO_ID := NEXTVAL('MOVING_OBJECT_SEQ');
  INSERT INTO MOVING_OBJECT(
    MO_ID, DESCRIPTION, MO_TYPE_ID)
  VALUES(
    P_MOVING_OBJECT.MO_ID, P_MOVING_OBJECT.DESCRIPTION, P_MOVING_OBJECT.MO_TYPE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_moving_object" type="moving_object_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_create_many(INOUT p_moving_object_a moving_object_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MOVING_OBJECT from an array of MOVING_OBJECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_MOVING_OBJECT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_MOVING_OBJECT_A[I].MO_ID := NEXTVAL('MOVING_OBJECT_SEQ');
  END LOOP;
  INSERT INTO MOVING_OBJECT(
    MO_ID, DESCRIPTION, MO_TYPE_ID)
  SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM UNNEST(P_MOVING_OBJECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_moving_object_a" type="moving_object_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_delete(IN p_moving_object_a moving_object_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOVING_OBJECT based on array of MOVING_OBJECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MOVING_OBJECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOVING_OBJECT_A) P
    WHERE 
      P.MO_ID = T.MO_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_moving_object_a" type="moving_object_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MOVING_OBJECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MOVING_OBJECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_delete_by_id(IN p_mo_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOVING_OBJECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MOVING_OBJECT
  WHERE 
    MO_ID = P_MO_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_delete_by_name(IN p_description character varying)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOVING_OBJECT based on name]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM MOVING_OBJECT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_find_all()" returnType="SETOF moving_object_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOVING_OBJECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_find_by_id(p_mo_id integer)" returnType="SETOF moving_object_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOVING_OBJECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT
  WHERE 
    MO_ID = P_MO_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_find_by_name(p_description character varying)" returnType="SETOF moving_object_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOVING_OBJECT based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, DESCRIPTION, MO_TYPE_ID
  FROM MOVING_OBJECT
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on MOVING_OBJECT_MO_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM MOVING_OBJECT_MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_create(INOUT p_moving_object_mo_dr moving_object_mo_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on MOVING_OBJECT_MO_DR from a MOVING_OBJECT_MO_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOVING_OBJECT_MO_DR(
    MO_ID, RULE_ID)
  VALUES(
    P_MOVING_OBJECT_MO_DR.MO_ID, P_MOVING_OBJECT_MO_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_moving_object_mo_dr" type="moving_object_mo_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_create_many(INOUT p_moving_object_mo_dr_a moving_object_mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on MOVING_OBJECT_MO_DR from an array of MOVING_OBJECT_MO_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO MOVING_OBJECT_MO_DR(
    MO_ID, RULE_ID)
  SELECT
    MO_ID, RULE_ID
  FROM UNNEST(P_MOVING_OBJECT_MO_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_moving_object_mo_dr_a" type="moving_object_mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_delete(IN p_moving_object_mo_dr_a moving_object_mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on MOVING_OBJECT_MO_DR based on array of MOVING_OBJECT_MO_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    MOVING_OBJECT_MO_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_MOVING_OBJECT_MO_DR_A) P
    WHERE 
      P.MO_ID = T.MO_ID AND
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_moving_object_mo_dr_a" type="moving_object_mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on MOVING_OBJECT_MO_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM MOVING_OBJECT_MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_find_all()" returnType="SETOF moving_object_mo_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOVING_OBJECT_MO_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, RULE_ID
  FROM MOVING_OBJECT_MO_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_find_by_id(p_mo_id integer, p_rule_id integer)" returnType="SETOF moving_object_mo_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on MOVING_OBJECT_MO_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    MO_ID, RULE_ID
  FROM MOVING_OBJECT_MO_DR
  WHERE 
    MO_ID = P_MO_ID AND
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_mo_id" type="integer"/>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_mo_dr_update(IN p_moving_object_mo_dr_a moving_object_mo_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MOVING_OBJECT_MO_DR based on array of MOVING_OBJECT_MO_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MOVING_OBJECT_MO_DR E
  SET 
    MO_ID=P.MO_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_MOVING_OBJECT_MO_DR_A) P
  WHERE 
    E.MO_ID = P.MO_ID AND
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_moving_object_mo_dr_a" type="moving_object_mo_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="moving_object_update(IN p_moving_object_a moving_object_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on MOVING_OBJECT based on array of MOVING_OBJECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE MOVING_OBJECT E
  SET 
    MO_ID=P.MO_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    MO_TYPE_ID=P.MO_TYPE_ID
  FROM UNNEST(P_MOVING_OBJECT_A) P
  WHERE 
    E.MO_ID = P.MO_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_moving_object_a" type="moving_object_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on POINT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM POINT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_create(INOUT p_point_aspect point_aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on POINT_ASPECT from a POINT_ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_ASPECT(
    POINT_ID, ASPECT_ID)
  VALUES(
    P_POINT_ASPECT.POINT_ID, P_POINT_ASPECT.ASPECT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_aspect" type="point_aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_create_many(INOUT p_point_aspect_a point_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on POINT_ASPECT from an array of POINT_ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_ASPECT(
    POINT_ID, ASPECT_ID)
  SELECT
    POINT_ID, ASPECT_ID
  FROM UNNEST(P_POINT_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_aspect_a" type="point_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_delete(IN p_point_aspect_a point_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_ASPECT based on array of POINT_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    POINT_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_ASPECT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_aspect_a" type="point_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on POINT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM POINT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_delete_by_id(IN p_point_id integer, IN p_aspect_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM POINT_ASPECT
  WHERE 
    POINT_ID = P_POINT_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_find_all()" returnType="SETOF point_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, ASPECT_ID
  FROM POINT_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_find_by_id(p_point_id integer, p_aspect_id integer)" returnType="SETOF point_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, ASPECT_ID
  FROM POINT_ASPECT
  WHERE 
    POINT_ID = P_POINT_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_aspect_update(IN p_point_aspect_a point_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on POINT_ASPECT based on array of POINT_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE POINT_ASPECT E
  SET 
    POINT_ID=P.POINT_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_POINT_ASPECT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_aspect_a" type="point_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_create(INOUT p_point point_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on POINT from a POINT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_POINT.POINT_ID := NEXTVAL('POINT_SEQ');
  INSERT INTO POINT(
    POINT_ID, P_ORDER, MAT_ID, T)
  VALUES(
    P_POINT.POINT_ID, P_POINT.P_ORDER, P_POINT.MAT_ID, P_POINT.T);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point" type="point_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_create_many(INOUT p_point_a point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on POINT from an array of POINT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_POINT_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_POINT_A[I].POINT_ID := NEXTVAL('POINT_SEQ');
  END LOOP;
  INSERT INTO POINT(
    POINT_ID, P_ORDER, MAT_ID, T)
  SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM UNNEST(P_POINT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_a" type="point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_delete(IN p_point_a point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT based on array of POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_a" type="point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on POINT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_delete_by_id(IN p_point_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM POINT
  WHERE 
    POINT_ID = P_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on POINT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_create(INOUT p_point_dr point_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on POINT_DR from a POINT_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_DR(
    RULE_ID)
  VALUES(
    P_POINT_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_dr" type="point_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_create_many(INOUT p_point_dr_a point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on POINT_DR from an array of POINT_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_DR(
    RULE_ID)
  SELECT
    RULE_ID
  FROM UNNEST(P_POINT_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_dr_a" type="point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_delete(IN p_point_dr_a point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_DR based on array of POINT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    POINT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_DR_A) P
    WHERE 
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_dr_a" type="point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on POINT_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_find_all()" returnType="SETOF point_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_find_by_id(p_rule_id integer)" returnType="SETOF point_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    RULE_ID
  FROM POINT_DR
  WHERE 
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_dr_update(IN p_point_dr_a point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on POINT_DR based on array of POINT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE POINT_DR E
  SET 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_POINT_DR_A) P
  WHERE 
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_dr_a" type="point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_find_all()" returnType="SETOF point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_find_by_id(p_point_id integer)" returnType="SETOF point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, P_ORDER, MAT_ID, T
  FROM POINT
  WHERE 
    POINT_ID = P_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on POINT_POINT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM POINT_POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_create(INOUT p_point_point_dr point_point_dr_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on POINT_POINT_DR from a POINT_POINT_DR_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_POINT_DR(
    POINT_ID, RULE_ID)
  VALUES(
    P_POINT_POINT_DR.POINT_ID, P_POINT_POINT_DR.RULE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_point_dr" type="point_point_dr_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_create_many(INOUT p_point_point_dr_a point_point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on POINT_POINT_DR from an array of POINT_POINT_DR_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_POINT_DR(
    POINT_ID, RULE_ID)
  SELECT
    POINT_ID, RULE_ID
  FROM UNNEST(P_POINT_POINT_DR_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_point_dr_a" type="point_point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_delete(IN p_point_point_dr_a point_point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_POINT_DR based on array of POINT_POINT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    POINT_POINT_DR T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_POINT_DR_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.RULE_ID = T.RULE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_point_dr_a" type="point_point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on POINT_POINT_DR]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM POINT_POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_find_all()" returnType="SETOF point_point_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_POINT_DR]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, RULE_ID
  FROM POINT_POINT_DR;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_find_by_id(p_point_id integer, p_rule_id integer)" returnType="SETOF point_point_dr_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_POINT_DR based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, RULE_ID
  FROM POINT_POINT_DR
  WHERE 
    POINT_ID = P_POINT_ID AND
    RULE_ID = P_RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
            <parameter mode="IN" name="p_rule_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_point_dr_update(IN p_point_point_dr_a point_point_dr_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on POINT_POINT_DR based on array of POINT_POINT_DR_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE POINT_POINT_DR E
  SET 
    POINT_ID=P.POINT_ID, 
    RULE_ID=P.RULE_ID
  FROM UNNEST(P_POINT_POINT_DR_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.RULE_ID = P.RULE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_point_dr_a" type="point_point_dr_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on POINT_REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM POINT_REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_create(INOUT p_point_repr_point point_repr_point_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on POINT_REPR_POINT from a POINT_REPR_POINT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_REPR_POINT(
    POINT_ID, REPR_POINT_ID)
  VALUES(
    P_POINT_REPR_POINT.POINT_ID, P_POINT_REPR_POINT.REPR_POINT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_repr_point" type="point_repr_point_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_create_many(INOUT p_point_repr_point_a point_repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on POINT_REPR_POINT from an array of POINT_REPR_POINT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO POINT_REPR_POINT(
    POINT_ID, REPR_POINT_ID)
  SELECT
    POINT_ID, REPR_POINT_ID
  FROM UNNEST(P_POINT_REPR_POINT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_point_repr_point_a" type="point_repr_point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_delete(IN p_point_repr_point_a point_repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_REPR_POINT based on array of POINT_REPR_POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    POINT_REPR_POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_POINT_REPR_POINT_A) P
    WHERE 
      P.POINT_ID = T.POINT_ID AND
      P.REPR_POINT_ID = T.REPR_POINT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_repr_point_a" type="point_repr_point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on POINT_REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM POINT_REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_delete_by_id(IN p_point_id integer, IN p_repr_point_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on POINT_REPR_POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM POINT_REPR_POINT
  WHERE 
    POINT_ID = P_POINT_ID AND
    REPR_POINT_ID = P_REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
            <parameter mode="IN" name="p_repr_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_find_all()" returnType="SETOF point_repr_point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, REPR_POINT_ID
  FROM POINT_REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_find_by_id(p_point_id integer, p_repr_point_id integer)" returnType="SETOF point_repr_point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on POINT_REPR_POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    POINT_ID, REPR_POINT_ID
  FROM POINT_REPR_POINT
  WHERE 
    POINT_ID = P_POINT_ID AND
    REPR_POINT_ID = P_REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_id" type="integer"/>
            <parameter mode="IN" name="p_repr_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_repr_point_update(IN p_point_repr_point_a point_repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on POINT_REPR_POINT based on array of POINT_REPR_POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE POINT_REPR_POINT E
  SET 
    POINT_ID=P.POINT_ID, 
    REPR_POINT_ID=P.REPR_POINT_ID
  FROM UNNEST(P_POINT_REPR_POINT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID AND
    E.REPR_POINT_ID = P.REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_repr_point_a" type="point_repr_point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="point_update(IN p_point_a point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on POINT based on array of POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE POINT E
  SET 
    POINT_ID=P.POINT_ID, 
    P_ORDER=P.P_ORDER, 
    MAT_ID=P.MAT_ID, 
    T=P.T
  FROM UNNEST(P_POINT_A) P
  WHERE 
    E.POINT_ID = P.POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_point_a" type="point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on PREDICATE_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM PREDICATE_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_create(INOUT p_predicate_aspect predicate_aspect_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on PREDICATE_ASPECT from a PREDICATE_ASPECT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO PREDICATE_ASPECT(
    PREDICATE_ID, ASPECT_ID)
  VALUES(
    P_PREDICATE_ASPECT.PREDICATE_ID, P_PREDICATE_ASPECT.ASPECT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate_aspect" type="predicate_aspect_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_create_many(INOUT p_predicate_aspect_a predicate_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on PREDICATE_ASPECT from an array of PREDICATE_ASPECT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO PREDICATE_ASPECT(
    PREDICATE_ID, ASPECT_ID)
  SELECT
    PREDICATE_ID, ASPECT_ID
  FROM UNNEST(P_PREDICATE_ASPECT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate_aspect_a" type="predicate_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_delete(IN p_predicate_aspect_a predicate_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on PREDICATE_ASPECT based on array of PREDICATE_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    PREDICATE_ASPECT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_ASPECT_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID AND
      P.ASPECT_ID = T.ASPECT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_aspect_a" type="predicate_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on PREDICATE_ASPECT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM PREDICATE_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_find_all()" returnType="SETOF predicate_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE_ASPECT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, ASPECT_ID
  FROM PREDICATE_ASPECT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_find_by_id(p_predicate_id integer, p_aspect_id integer)" returnType="SETOF predicate_aspect_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE_ASPECT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, ASPECT_ID
  FROM PREDICATE_ASPECT
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID AND
    ASPECT_ID = P_ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on PREDICATE_ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM PREDICATE_ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_create(INOUT p_predicate_aspect_type predicate_aspect_type_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on PREDICATE_ASPECT_TYPE from a PREDICATE_ASPECT_TYPE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO PREDICATE_ASPECT_TYPE(
    PREDICATE_ID, ASPECT_TYPE_ID)
  VALUES(
    P_PREDICATE_ASPECT_TYPE.PREDICATE_ID, P_PREDICATE_ASPECT_TYPE.ASPECT_TYPE_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate_aspect_type" type="predicate_aspect_type_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_create_many(INOUT p_predicate_aspect_type_a predicate_aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on PREDICATE_ASPECT_TYPE from an array of PREDICATE_ASPECT_TYPE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO PREDICATE_ASPECT_TYPE(
    PREDICATE_ID, ASPECT_TYPE_ID)
  SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate_aspect_type_a" type="predicate_aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_delete(IN p_predicate_aspect_type_a predicate_aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on PREDICATE_ASPECT_TYPE based on array of PREDICATE_ASPECT_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    PREDICATE_ASPECT_TYPE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID AND
      P.ASPECT_TYPE_ID = T.ASPECT_TYPE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_aspect_type_a" type="predicate_aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on PREDICATE_ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM PREDICATE_ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_find_all()" returnType="SETOF predicate_aspect_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE_ASPECT_TYPE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM PREDICATE_ASPECT_TYPE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_find_by_id(p_predicate_id integer, p_aspect_type_id integer)" returnType="SETOF predicate_aspect_type_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE_ASPECT_TYPE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, ASPECT_TYPE_ID
  FROM PREDICATE_ASPECT_TYPE
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID AND
    ASPECT_TYPE_ID = P_ASPECT_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_id" type="integer"/>
            <parameter mode="IN" name="p_aspect_type_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_type_update(IN p_predicate_aspect_type_a predicate_aspect_type_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on PREDICATE_ASPECT_TYPE based on array of PREDICATE_ASPECT_TYPE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE PREDICATE_ASPECT_TYPE E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    ASPECT_TYPE_ID=P.ASPECT_TYPE_ID
  FROM UNNEST(P_PREDICATE_ASPECT_TYPE_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID AND
    E.ASPECT_TYPE_ID = P.ASPECT_TYPE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_aspect_type_a" type="predicate_aspect_type_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_aspect_update(IN p_predicate_aspect_a predicate_aspect_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on PREDICATE_ASPECT based on array of PREDICATE_ASPECT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE PREDICATE_ASPECT E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    ASPECT_ID=P.ASPECT_ID
  FROM UNNEST(P_PREDICATE_ASPECT_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID AND
    E.ASPECT_ID = P.ASPECT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_aspect_a" type="predicate_aspect_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on PREDICATE]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM PREDICATE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_create(INOUT p_predicate predicate_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on PREDICATE from a PREDICATE_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  P_PREDICATE.PREDICATE_ID := NEXTVAL('PREDICATE_SEQ');
  INSERT INTO PREDICATE(
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED)
  VALUES(
    P_PREDICATE.PREDICATE_ID, P_PREDICATE.DESCRIPTION, P_PREDICATE.PREDICATE_ORDER, P_PREDICATE.PREDICATE_PATH, P_PREDICATE.PARENTHESIS_TYPE, P_PREDICATE.PARENTHESIS_AMOUNT, P_PREDICATE.LOGICAL_OPERATOR, P_PREDICATE.DETERMINANT, P_PREDICATE.DETERMINED);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate" type="predicate_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_create_many(INOUT p_predicate_a predicate_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on PREDICATE from an array of PREDICATE_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  V_INPUT_LENGTH INTEGER;
BEGIN
  V_INPUT_LENGTH := ARRAY_LENGTH(P_PREDICATE_A, 1);
  FOR I IN 1..V_INPUT_LENGTH LOOP
    P_PREDICATE_A[I].PREDICATE_ID := NEXTVAL('PREDICATE_SEQ');
  END LOOP;
  INSERT INTO PREDICATE(
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED)
  SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM UNNEST(P_PREDICATE_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_predicate_a" type="predicate_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_delete(IN p_predicate_a predicate_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on PREDICATE based on array of PREDICATE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    PREDICATE T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_PREDICATE_A) P
    WHERE 
      P.PREDICATE_ID = T.PREDICATE_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_a" type="predicate_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on PREDICATE]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM PREDICATE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_find_all()" returnType="SETOF predicate_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_find_by_id(p_predicate_id integer)" returnType="SETOF predicate_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE
  WHERE 
    PREDICATE_ID = P_PREDICATE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_find_by_name(p_description character varying)" returnType="SETOF predicate_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on PREDICATE based on name or description]]></comment>
         <definition language="sql"><![CDATA[SELECT
    PREDICATE_ID, DESCRIPTION, PREDICATE_ORDER, PREDICATE_PATH, PARENTHESIS_TYPE, PARENTHESIS_AMOUNT, LOGICAL_OPERATOR, DETERMINANT, DETERMINED
  FROM PREDICATE
  WHERE DESCRIPTION = P_DESCRIPTION;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_description" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="predicate_update(IN p_predicate_a predicate_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on PREDICATE based on array of PREDICATE_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE PREDICATE E
  SET 
    PREDICATE_ID=P.PREDICATE_ID, 
    DESCRIPTION=P.DESCRIPTION, 
    PREDICATE_ORDER=P.PREDICATE_ORDER, 
    PREDICATE_PATH=P.PREDICATE_PATH, 
    PARENTHESIS_TYPE=P.PARENTHESIS_TYPE, 
    PARENTHESIS_AMOUNT=P.PARENTHESIS_AMOUNT, 
    LOGICAL_OPERATOR=P.LOGICAL_OPERATOR, 
    DETERMINANT=P.DETERMINANT, 
    DETERMINED=P.DETERMINED
  FROM UNNEST(P_PREDICATE_A) P
  WHERE 
    E.PREDICATE_ID = P.PREDICATE_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_predicate_a" type="predicate_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_count()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Counts ocurrences on REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT COUNT(*) AS CNT FROM REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_create(INOUT p_repr_point repr_point_typ)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates one tuple on REPR_POINT from a REPR_POINT_TYP object]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO REPR_POINT(
    REPR_POINT_ID)
  VALUES(
    P_REPR_POINT.REPR_POINT_ID);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_repr_point" type="repr_point_typ"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_create_many(INOUT p_repr_point_a repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Creates tuples on REPR_POINT from an array of REPR_POINT_TYP objects]]></comment>
         <definition language="plpgsql"><![CDATA[BEGIN
  INSERT INTO REPR_POINT(
    REPR_POINT_ID)
  SELECT
    REPR_POINT_ID
  FROM UNNEST(P_REPR_POINT_A);
END;]]></definition>
         <parameters>
            <parameter mode="INOUT" name="p_repr_point_a" type="repr_point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_delete(IN p_repr_point_a repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on REPR_POINT based on array of REPR_POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[DELETE FROM 
    REPR_POINT T
  WHERE EXISTS (
    SELECT 1
    FROM UNNEST(P_REPR_POINT_A) P
    WHERE 
      P.REPR_POINT_ID = T.REPR_POINT_ID);]]></definition>
         <parameters>
            <parameter mode="IN" name="p_repr_point_a" type="repr_point_typ[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_delete_all()" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete all ocurrences on REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[DELETE    
  FROM REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_delete_by_id(IN p_repr_point_id integer)" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Delete ocurrences on REPR_POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[DELETE
  FROM REPR_POINT
  WHERE 
    REPR_POINT_ID = P_REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_repr_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_find_all()" returnType="SETOF repr_point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on REPR_POINT]]></comment>
         <definition language="sql"><![CDATA[SELECT
    REPR_POINT_ID
  FROM REPR_POINT;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_find_by_id(p_repr_point_id integer)" returnType="SETOF repr_point_typ" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Find all ocurrences on REPR_POINT based on primary key]]></comment>
         <definition language="sql"><![CDATA[SELECT
    REPR_POINT_ID
  FROM REPR_POINT
  WHERE 
    REPR_POINT_ID = P_REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_repr_point_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="repr_point_update(IN p_repr_point_a repr_point_typ[])" securityType="INVOKER" type="PROCEDURE">
         <comment><![CDATA[Updates all ocurrences on REPR_POINT based on array of REPR_POINT_TYP objects]]></comment>
         <definition language="sql"><![CDATA[UPDATE REPR_POINT E
  SET 
    REPR_POINT_ID=P.REPR_POINT_ID
  FROM UNNEST(P_REPR_POINT_A) P
  WHERE 
    E.REPR_POINT_ID = P.REPR_POINT_ID;]]></definition>
         <parameters>
            <parameter mode="IN" name="p_repr_point_a" type="repr_point_typ[]"/>
         </parameters>
      </routine>
   </routines>
</database>
